<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>差分隐私综述</title>
    <url>/post/46d864ff.html</url>
    <content><![CDATA[<h3 id="1-差分隐私的两个目标"><a href="#1-差分隐私的两个目标" class="headerlink" title="1.差分隐私的两个目标"></a>1.差分隐私的两个目标</h3><p>（1）隐私保护中, 如何在分享数据时定义隐私</p>
<p>（2）如何在保证可用性的数据发布时, 提供隐私保护的问题</p>
<span id="more"></span>

<h3 id="2-差分隐私背景："><a href="#2-差分隐私背景：" class="headerlink" title="2.差分隐私背景："></a>2.差分隐私背景：</h3><p>差分隐私对于隐私的定义不依赖于攻击者的背景知识</p>
<h3 id="3-隐私信息的全生命周期模型（9个部分）"><a href="#3-隐私信息的全生命周期模型（9个部分）" class="headerlink" title="3.隐私信息的全生命周期模型（9个部分）"></a>3.隐私信息的全生命周期模型（9个部分）</h3><p>隐私信息产生, 隐私感知, 隐私保护, 隐私发布, 隐私信息存储, 隐私交换, 隐私分析, 隐私销毁, 隐私接收者</p>
<h3 id="4-隐私保护的方式（主要有三种）"><a href="#4-隐私保护的方式（主要有三种）" class="headerlink" title="4.隐私保护的方式（主要有三种）"></a>4.隐私保护的方式（主要有三种）</h3><p>数据失真、加密、访问控制</p>
<h3 id="5-准标识符"><a href="#5-准标识符" class="headerlink" title="5.准标识符"></a>5.准标识符</h3><p>可以和外部表链接来识别个体的最小属性集</p>
<h3 id="6-准标识符假设"><a href="#6-准标识符假设" class="headerlink" title="6.准标识符假设"></a>6.准标识符假设</h3><p>数据持有者可以识别出其所持有数据表中可能出现在外部数据中的属性，因此其可以准确的识别出准标识符集合（实际上这个假设不可能成立）</p>
<h3 id="7-K匿名算法"><a href="#7-K匿名算法" class="headerlink" title="7.K匿名算法"></a>7.K匿名算法</h3><p>通过概括和隐匿技术，发布精度较低的技术，使得每条记录至少与数据表中其他k-1条记录具有完全相同的准标识符属性值，从而减少链接攻击所导致的隐私泄露。</p>
<p>缺点：无法抵抗同质攻击，背景知识攻击和补充数据攻击等</p>
<h3 id="8-等价类"><a href="#8-等价类" class="headerlink" title="8.等价类"></a>8.等价类</h3><p>拥有相同准标识符的所有记录</p>
<h3 id="9-l-diversity（l-多样性）"><a href="#9-l-diversity（l-多样性）" class="headerlink" title="9.l-diversity（l-多样性）"></a>9.l-diversity（l-多样性）</h3><p>一个等价类里的敏感属性至少有l个良表示的取值</p>
<p>缺点：因为在一个真实的数据集中, 属性值很有可能是偏斜的或者语义相近的, 而 l-多样性只保证了多样性，没有认识到在属性值上语义相近的情况</p>
<h3 id="10-可区分良表示"><a href="#10-可区分良表示" class="headerlink" title="10.可区分良表示"></a>10.可区分良表示</h3><p>同一等价类中的敏感属性至少有l个可区分的取值</p>
<h3 id="11-顺序合成性质、平行合成性质"><a href="#11-顺序合成性质、平行合成性质" class="headerlink" title="11.顺序合成性质、平行合成性质"></a>11.顺序合成性质、平行合成性质</h3><p>一个算法序列同时作用在一个数据集上时；多个算法序列分别作用在一个数据集上多个不同子集上时</p>
<h3 id="12-控制隐私预算的目的"><a href="#12-控制隐私预算的目的" class="headerlink" title="12.控制隐私预算的目的"></a>12.控制隐私预算的目的</h3><p>如果在一个较低隐私预算参数的情况下, 攻击者对一个数据集进行了多次查询, 那么根据顺序合成性质, 攻击者实际上获得的隐私预算就相当于获得了多次查询的隐私预算的和, 而这就破坏了原本设定的隐私预算，所以需要控制隐私预算的上限。</p>
<h3 id="13-变换不变性"><a href="#13-变换不变性" class="headerlink" title="13.变换不变性"></a>13.变换不变性</h3><p>满足差分隐私的算法经过后处理之后仍然满足差分隐私</p>
<h3 id="14-中凸性"><a href="#14-中凸性" class="headerlink" title="14.中凸性"></a>14.中凸性</h3><p>如果有2个不同的差分隐私算法, 都提供了足够的不确定性来保护隐私, 那么可以通过选择任意的算法来应用到数据上实现对数据的隐私保护, 只要选择的算法和数据是独立的</p>
<h3 id="15-曼哈顿距离"><a href="#15-曼哈顿距离" class="headerlink" title="15.曼哈顿距离"></a>15.曼哈顿距离</h3><p>两个点在标准坐标系上的绝对轴距综合。这里的曼哈顿距离就相当于对称差值，其度量了修改一个元组时查询结果的最大变化</p>
<h3 id="16-全局敏感度（与数据集无关，只由查询函数本身决定）"><a href="#16-全局敏感度（与数据集无关，只由查询函数本身决定）" class="headerlink" title="16.全局敏感度（与数据集无关，只由查询函数本身决定）"></a>16.全局敏感度（与数据集无关，只由查询函数本身决定）</h3><p>控制噪声的重要参数。定义为查询函数f作用于任意两个相邻数据集得到的查询结果的曼哈顿距离</p>
<h3 id="17-局部敏感度（由查询函数和给定的数据集共同决定）"><a href="#17-局部敏感度（由查询函数和给定的数据集共同决定）" class="headerlink" title="17.局部敏感度（由查询函数和给定的数据集共同决定）"></a>17.局部敏感度（由查询函数和给定的数据集共同决定）</h3><p>定义为查询函数f作用于给定两个相邻数据集得到的查询结果的曼哈顿距离</p>
<p>缺陷：局部敏感度不满足差分隐私的要求，因为噪声大小本身可能会揭示数据库信息</p>
<h3 id="18-平滑上界、平滑敏感度（为了弥补局部敏感度的缺陷而提出）"><a href="#18-平滑上界、平滑敏感度（为了弥补局部敏感度的缺陷而提出）" class="headerlink" title="18.平滑上界、平滑敏感度（为了弥补局部敏感度的缺陷而提出）"></a>18.平滑上界、平滑敏感度（为了弥补局部敏感度的缺陷而提出）</h3><h3 id="19-拉普拉斯机制"><a href="#19-拉普拉斯机制" class="headerlink" title="19.拉普拉斯机制"></a>19.拉普拉斯机制</h3><p>在查询结果上加入一个满足拉普拉斯分布的噪声来实现差分隐私保护，所加入的拉普拉斯噪声的均值要求为 0，这样输出的才是无偏估计</p>
<h3 id="20-指数机制"><a href="#20-指数机制" class="headerlink" title="20.指数机制"></a>20.指数机制</h3><p>对于任意一个可用性函数q和一个差分隐私预算 , 随机算法 M 以正比于的概率输出一个o作为结果</p>
<img src="/post/46d864ff/1.png" class title="指数机制">

<h3 id="21-SSE、MSE、RMSE"><a href="#21-SSE、MSE、RMSE" class="headerlink" title="21.SSE、MSE、RMSE"></a>21.SSE、MSE、RMSE</h3><p>和方差、均方误差、均方根误差</p>
<h3 id="22-隐私预算表达式"><a href="#22-隐私预算表达式" class="headerlink" title="22.隐私预算表达式"></a>22.隐私预算表达式</h3><img src="/post/46d864ff/2.png" class title="隐私预算">

<h3 id="23-研究现状"><a href="#23-研究现状" class="headerlink" title="23.研究现状"></a>23.研究现状</h3><p>（1）差分隐私虽然现在已经被用于数据挖掘，推荐系统等领域，但是差分隐私对于挖掘数据保护后，还能对数据分析者提供多少可用信息目前还没有一个合理通用的度量方法</p>
<p>（2）差分隐私与机器学习的结合将是未来的一个研究热点</p>
<p>（3）在差分隐私和机器学习中，主要有以下问题需要解决</p>
<p>​			（a）因为传统机器学习方法不能满足差分隐私的需求，需要解决样本数据集中缺失数据的问题</p>
<p>​			（b）医疗数据集中, 很多体征数据只是暂时的，而且对于数据的扰动很有可能使数据失去重要的信息, 因此需要有应对这种类型数据的差分隐私模型</p>
<p>​			（c）隐私是否能在不牺牲机器学习模型可用性的条件下实现</p>
<p>​			（d）在正则化的机器学习模型中, 差分隐私是否可以与正则化的想法兼容</p>
]]></content>
      <categories>
        <category>差分隐私（中文综述）</category>
      </categories>
      <tags>
        <tag>差分隐私</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo和Github搭建博客</title>
    <url>/post/bf8017ed.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本人的博客采用<code>Hexo+Github</code>的方式完成，采用这两者相结合的方式的原因在于：一方面，虽然<code>Hexo</code>是一个静态博客框架，但是本人觉得个人博客只在于记录一些学习过程中的心得和学习笔记，所以静态博客框架完全可以满足这种需求；另一方面，<code>Github</code>提供了<code>Github Pages</code>这种免费的静态站点托管服务，这对于我这种学生党来说无疑是一种福音。</p>
<span id="more"></span>

<h1 id="Hexo版本信息"><a href="#Hexo版本信息" class="headerlink" title="Hexo版本信息"></a>Hexo版本信息</h1><p>鉴于Hexo框架更新迭代较快，当版本不同时很多配置文件都不相同，因此建议选择对应版本的教程进行阅读。以下是本人的Hexo版本具体信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hp@LAPTOP-RB9QDBHV MINGW64 /f/My-Blog</span><br><span class="line">$ hexo v</span><br><span class="line">NexT version 8.12.2</span><br><span class="line">Documentation: https://theme-next.js.org</span><br><span class="line">========================================</span><br><span class="line">hexo: 6.2.0</span><br><span class="line">hexo-cli: 4.3.0</span><br><span class="line">os: win32 10.0.19043</span><br><span class="line">node: 14.15.1</span><br><span class="line">v8: 8.4.371.19-node.17</span><br><span class="line">uv: 1.40.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.9</span><br><span class="line">ares: 1.16.1</span><br><span class="line">modules: 83</span><br><span class="line">nghttp2: 1.41.0</span><br><span class="line">napi: 7</span><br><span class="line">llhttp: 2.1.3</span><br><span class="line">openssl: 1.1.1g</span><br><span class="line">cldr: 37.0</span><br><span class="line">icu: 67.1</span><br><span class="line">tz: 2020a</span><br><span class="line">unicode: 13.0</span><br></pre></td></tr></table></figure>

<h1 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h1><p>Hexo博客的搭建已于Node.js，博客搭建过程中需要使用Git进行博客版本控制，因此首先需要安装这两个工具：</p>
<blockquote>
<p>（1）Node.js: <code>http://nodejs.cn/download/</code></p>
<p>（2）Git: <code>https://git-scm.com/downloads</code></p>
</blockquote>
<p>安装完成之后，<code>Win+R</code>输入<code>cmd</code>打开命令行窗口，输入<code>node -v</code>, <code>npm -v</code>, <code>git --version</code>检查是否安装成功（ps：<code>Node.js</code>中安装了<code>npm</code>命令安装模块，因此不需要额外安装）。若<code>cmd</code>窗口如下图所示，说明安装成功，如下图所示：</p>
<img src="/post/bf8017ed/1.png" class title="安装检查">

<h1 id="2-创建Github仓库"><a href="#2-创建Github仓库" class="headerlink" title="2.创建Github仓库"></a>2.创建Github仓库</h1><p>首先需要使用<code>Git</code>命令行连接到自己的<code>Github</code>账号（这个网上教程很多，这里不再赘述）；因为需要使用<code>Github Pages</code>服务，所以需要在<code>Github</code>中先创建一个仓库，：<code>Repository name</code>中填入<code>Github用户名.github.io</code>，并勾选<code>Add a README file</code>，如下图所示：</p>
<img src="/post/bf8017ed/2.png" class title="创建Github仓库">

<h1 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h1><p>首先需要在本地新建一个文件夹用于存放博客程序所有文件，例如<code>My-Blog</code>。然后进入<code>My-Blog</code>文件夹，右键选择<code>Git Bash Here</code>打开<code>Git</code>命令窗口，然后依次输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli		# 安装Hexo博客程序</span><br><span class="line">hexo init					# 初始化</span><br><span class="line">npm install					# 安装组件</span><br><span class="line">hexo g						# 生成页面</span><br><span class="line">hexo s						# 启动预览</span><br></pre></td></tr></table></figure>

<p>访问<code>http://localhost:4000</code>，若出现<code>Hexo</code>默认界面，则说明安装成功。</p>
<h1 id="4-部署Hexo至Github"><a href="#4-部署Hexo至Github" class="headerlink" title="4.部署Hexo至Github"></a>4.部署Hexo至Github</h1><p>首先安装<code>hexo-deployer-git</code>插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后修改站点配置文件（<code>My-Blog/_config.yml</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:用户名/用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>然后在<code>Git</code>命令窗口中输入<code>hexo d</code>命令将博客上传部署到<code>Github Pages</code>中。</p>
<p>注意到我们这里是将<code>Hexo</code>博客上传到了<code>master</code>分支，因此需要在中将默认分支改为<code>master</code>，如下图所示：</p>
<img src="/post/bf8017ed/3.png" class title="更改默认分支">

<p>至此所有安装部署操作均已完成，这时访问<code>https://用户名.github.io</code>就可以看到我们自己的网站了！</p>
<h1 id="5-创建并发布文章"><a href="#5-创建并发布文章" class="headerlink" title="5.创建并发布文章"></a>5.创建并发布文章</h1><p>首先打开本地博客程序根目录（<code>My-Blog</code>），右键选择<code>Git Bash Here</code>，输入以下命令创建文章：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;文章名称&quot;</span><br></pre></td></tr></table></figure>

<p>此时会发现在<code>My-Blog/source/_posts</code>文件夹中出现了“文章名称.md”文件，然后便可在本地打开该文件进行文章的内容编辑（建议使用<code>Typora</code>）。</p>
<p>文章写完之后需要执行<code>hexo g</code>命令渲染成前端界面，然后执行<code>hexo d</code>命令部署到Github上，这样就完成了一篇文章的发布：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean	# 清除缓存文件（可以不执行该命令）</span><br><span class="line">hexo g		# 生成页面</span><br><span class="line">hexo d		# 部署页面</span><br></pre></td></tr></table></figure>

<h1 id="6-站点配置文件"><a href="#6-站点配置文件" class="headerlink" title="6.站点配置文件"></a>6.站点配置文件</h1><p>站点配置文件位于<code>My-Blog/_config.yml</code>该文件内容的介绍如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: 					# 博客标题</span><br><span class="line">subtitle: 				# 博客子标题</span><br><span class="line">description: 			# 博客描述</span><br><span class="line">keywords: 				# 关键词，用于SEO优化</span><br><span class="line">author: 				# 作者名称</span><br><span class="line">language: zh-CN			# 语言	</span><br><span class="line">timezone: 				# 时区</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="line">url: https://用户名.github.io/</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: :title.md 	# 新文章命名方式</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link:</span><br><span class="line">  enable: true # Open external links in new tab</span><br><span class="line">  field: site # Apply to the whole site</span><br><span class="line">  exclude: &#x27;&#x27;</span><br><span class="line"></span><br><span class="line"># Home page setting</span><br><span class="line"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><span class="line"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class="line"># order_by: Posts order. (Order by date descending by default)</span><br><span class="line">index_generator:</span><br><span class="line">  path: &#x27;&#x27;</span><br><span class="line">  per_page: 10		# 每页文章数量</span><br><span class="line">  order_by: -date	# 文章排序方法</span><br><span class="line"></span><br><span class="line"># 时间格式</span><br><span class="line"># Date / Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line">## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;</span><br><span class="line">updated_option: &#x27;mtime&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next			# 主题设置（选择My-Blog/themes文件夹下对应的主题目录名称）</span><br><span class="line"></span><br><span class="line"># 部署配置</span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:用户名/用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<h1 id="7-主题配置文件（Next）"><a href="#7-主题配置文件（Next）" class="headerlink" title="7.主题配置文件（Next）"></a>7.主题配置文件（Next）</h1><p>主题配置文件位于<code>My-Blog/themes/主题名称/_config.yml</code>鉴于<code>Next</code>主题集成了丰富的插件，且网上对于其优化的解决办法也相当充足，因此采用了<code>Next</code>主题，其主题配置文件如下所示（这里只展示部分配置，具体的美化配置请见后面的<code>Next美化配置</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 自定义文件（设置这些文件时，需要在My-Blog/source文件下新建对应的文件，并将对应的注释符号去除）</span><br><span class="line"># Define custom file paths.</span><br><span class="line"># Create your custom files in site directory `source/_data` and uncomment needed files below.</span><br><span class="line">custom_file_path:</span><br><span class="line">  #head: source/_data/head.njk</span><br><span class="line">  #header: source/_data/header.njk</span><br><span class="line">  #sidebar: source/_data/sidebar.njk</span><br><span class="line">  #postMeta: source/_data/post-meta.njk</span><br><span class="line">  #postBodyEnd: source/_data/post-body-end.njk</span><br><span class="line">  #footer: source/_data/footer.njk</span><br><span class="line">  #footer: source/_data/footer.njk</span><br><span class="line">  #bodyEnd: source/_data/body-end.njk</span><br><span class="line">  #variable: source/_data/variables.styl</span><br><span class="line">  #mixin: source/_data/mixins.styl</span><br><span class="line">  #style: source/_data/styles.styl</span><br><span class="line"></span><br><span class="line"># 主题格式设置（设置哪一种格式，就将哪一种格式前面的注释符合去除）</span><br><span class="line"># Schemes</span><br><span class="line">scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br><span class="line"></span><br><span class="line"># 网站图标设置（自定义网站图标时，需要将图标放置在My-Blog/themes/next/source/images文件夹下，并在下面设置相应的图标名称）</span><br><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16-next.png</span><br><span class="line">  medium: /images/favicon-32x32-next.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br><span class="line">  #android_manifest: /manifest.json</span><br><span class="line"></span><br><span class="line"># 菜单设置（在需要的标签前面去除注释符号即可展示在主页中）</span><br><span class="line">menu:</span><br><span class="line">  #home: / || fa fa-home</span><br><span class="line">  #about: /about/ || fa fa-user</span><br><span class="line">  #tags: /tags/ || fa fa-tags</span><br><span class="line">  #categories: /categories/ || fa fa-th</span><br><span class="line">  #archives: /archives/ || fa fa-archive</span><br><span class="line">  #schedule: /schedule/ || fa fa-calendar</span><br><span class="line">  #sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: /404/ || fa fa-heartbeat</span><br><span class="line"></span><br><span class="line"># 菜单图标设置</span><br><span class="line"># Enable / Disable menu icons / item badges.</span><br><span class="line">menu_settings:</span><br><span class="line">  icons: true</span><br><span class="line">  badges: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 侧边栏设置</span><br><span class="line">sidebar:</span><br><span class="line">  # 位置</span><br><span class="line">  # Sidebar Position.</span><br><span class="line">  position: left</span><br><span class="line">  #position: right</span><br><span class="line"></span><br><span class="line">  # 宽度</span><br><span class="line">  width: 300</span><br><span class="line"></span><br><span class="line">  # 展示方式</span><br><span class="line">  display: post</span><br><span class="line"></span><br><span class="line">  # Sidebar padding in pixels.</span><br><span class="line">  padding: 18</span><br><span class="line">  # Sidebar offset from top menubar in pixels (only for Pisces | Gemini).</span><br><span class="line">  offset: 12</span><br><span class="line"></span><br><span class="line"># 侧边栏头像设置</span><br><span class="line">avatar:</span><br><span class="line">  # 自定义头像需要在My-Blog/themes/next/source/images文件夹下放置头像，并对下面的url进行相应的修改</span><br><span class="line">  url: /images/avatar.png</span><br><span class="line">  # 是否以圆形进行展示（圆形/方形）</span><br><span class="line">  rounded: true</span><br><span class="line">  # 是否旋转</span><br><span class="line">  rotated: false</span><br><span class="line"></span><br><span class="line"># 社交链接设置（需要展示哪些社交链接只需去除其前面的注释）</span><br><span class="line">social:</span><br><span class="line">  #GitHub: https://github.com/yourname || fab fa-github</span><br><span class="line">  #E-Mail: mailto:yourname@gmail.com || fa fa-envelope</span><br><span class="line">  #Weibo: https://weibo.com/yourname || fab fa-weibo</span><br><span class="line">  #Google: https://plus.google.com/yourname || fab fa-google</span><br><span class="line">  #Twitter: https://twitter.com/yourname || fab fa-twitter</span><br><span class="line">  #FB Page: https://www.facebook.com/yourname || fab fa-facebook</span><br><span class="line">  #StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow</span><br><span class="line">  #YouTube: https://youtube.com/yourname || fab fa-youtube</span><br><span class="line">  #Instagram: https://instagram.com/yourname || fab fa-instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || fab fa-skype</span><br><span class="line">  </span><br><span class="line"># 社交链接图标设置</span><br><span class="line">social_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  icons_only: false		# 是否只展示图标</span><br><span class="line">  transition: false		# 是否需要过渡效果</span><br><span class="line"></span><br><span class="line"># 页脚设置</span><br><span class="line">footer:</span><br><span class="line">  # 展示网站创立的年份</span><br><span class="line">  since: 2022</span><br><span class="line"></span><br><span class="line">  # 网站创立时间和版权信息之间的图标</span><br><span class="line">  icon:</span><br><span class="line">    # Icon name in Font Awesome. See: https://fontawesome.com/icons</span><br><span class="line">    name: fa fa-user</span><br><span class="line">    # If you want to animate the icon, set it to true.</span><br><span class="line">    animated: false</span><br><span class="line">    # Change the color of icon, using Hex Code.</span><br><span class="line">    color: &quot;#999999&quot;</span><br><span class="line"></span><br><span class="line">  # If not defined, `author` from Hexo `_config.yml` will be used.</span><br><span class="line">  copyright:</span><br><span class="line"></span><br><span class="line">  # 是否需要在页脚展示&quot;Powered by Hexo &amp; NexT&quot;</span><br><span class="line">  powered: false</span><br><span class="line"></span><br><span class="line"># 是否需要&quot;回到顶部&quot;功能</span><br><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # Back to top in sidebar.</span><br><span class="line">  sidebar: false</span><br><span class="line">  # Scroll percent label in b2t button.</span><br><span class="line">  scrollpercent: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 是否需要点击图片放大功能</span><br><span class="line">fancybox: true</span><br></pre></td></tr></table></figure>

<h1 id="8-Next美化配置"><a href="#8-Next美化配置" class="headerlink" title="8.Next美化配置"></a>8.Next美化配置</h1><h2 id="8-1摘要文字长度"><a href="#8-1摘要文字长度" class="headerlink" title="8.1摘要文字长度"></a>8.1摘要文字长度</h2><p>摘要文字长度建议使用<code>&lt;!--more--&gt;</code>进行手动设置，很多插件虽然也能直接设置长度，但个人觉得插件实现的效果不是很好，具体实现方法如下：</p>
<p>首先在主题配置文件<code>My-Blog/themes/主题名称/_config.yml</code>中进行如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">excerpt_description: true</span><br><span class="line"></span><br><span class="line">read_more_btn: true</span><br></pre></td></tr></table></figure>

<p>然后在需要发布的文章的md文件中添加<code>&lt;!--more--&gt;</code>，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 文章标题</span><br><span class="line">tags: Hexo</span><br><span class="line">categories: 搭建博客</span><br><span class="line"></span><br><span class="line">摘要文字</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">其他内容</span><br></pre></td></tr></table></figure>

<p>这样设置之后，在文章摘要页面就只能看到”摘要文字”，而看不到”其他内容”。</p>
<h2 id="8-2文章末尾添加统一结束语"><a href="#8-2文章末尾添加统一结束语" class="headerlink" title="8.2文章末尾添加统一结束语"></a>8.2文章末尾添加统一结束语</h2><p>在<code>Hexo</code>博客程序根目录下的<code>source</code>文件夹中新建<code>_data/post-body-end.njk</code>文件，并进行如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px; padding-top: 10px;&quot;&gt;--------------------------------------- &lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt; 本文结束，感谢您的阅读 &lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt; ---------------------------------------  &lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>之后，需要在主题配置文件中查找<code>custom_file_path</code>，并去除<code>postBodyEnd: source/_data/post-body-end.njk</code>前面的注释符号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  #head: source/_data/head.njk</span><br><span class="line">  #header: source/_data/header.njk</span><br><span class="line">  #sidebar: source/_data/sidebar.njk</span><br><span class="line">  #postMeta: source/_data/post-meta.njk</span><br><span class="line">  postBodyEnd: source/_data/post-body-end.njk</span><br><span class="line">  #footer: source/_data/footer.njk</span><br><span class="line">  #footer: source/_data/footer.njk</span><br><span class="line">  #bodyEnd: source/_data/body-end.njk</span><br><span class="line">  #variable: source/_data/variables.styl</span><br><span class="line">  #mixin: source/_data/mixins.styl</span><br><span class="line">  #style: source/_data/styles.styl</span><br></pre></td></tr></table></figure>

<h2 id="8-3代码块"><a href="#8-3代码块" class="headerlink" title="8.3代码块"></a>8.3代码块</h2><p>进入主题配置文件<code>My-Blog/themes/主题名称/_config.yml</code>并进行如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  # 代码块主题</span><br><span class="line">  theme:</span><br><span class="line">    light: default</span><br><span class="line">    dark: stackoverflow-dark</span><br><span class="line">  prism:</span><br><span class="line">    light: prism</span><br><span class="line">    dark: prism-dark</span><br><span class="line">  # 是否支持一键复制</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    style: mac</span><br></pre></td></tr></table></figure>

<h2 id="8-4今日诗词"><a href="#8-4今日诗词" class="headerlink" title="8.4今日诗词"></a>8.4今日诗词</h2><p>在<code>Hexo</code>博客程序根目录下的<code>source</code>文件夹中新建<code>_data/post-body-end.njk</code>文件，并进行如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;//sdk.jinrishici.com/v2/browser/jinrishici.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  jinrishici.load((result) =&gt; &#123;</span><br><span class="line">    let jrsc = document.getElementById(&#x27;jrsc&#x27;);</span><br><span class="line">    const data = result.data;</span><br><span class="line">    let author = data.origin.author;</span><br><span class="line">    let title = &#x27;《&#x27; + data.origin.title + &#x27;》&#x27;;</span><br><span class="line">    let content = data.content.substr(0, data.content.length - 1);</span><br><span class="line">    let dynasty = data.origin.dynasty.substr(0, data.origin.dynasty.length - 1);</span><br><span class="line">    jrsc.innerText = content + &#x27; &#x27; + &#x27;[&#x27; + dynasty + &#x27;]&#x27; + author + title;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;div style=&quot;text-align: center&quot;&gt;&lt;span id=&quot;jrsc&quot; &gt;正在加载今日诗词....&lt;/span&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>之后，需要在主题配置文件中查找<code>custom_file_path</code>，并去除<code>postBodyEnd: source/_data/post-body-end.njk</code>前面的注释符号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  #head: source/_data/head.njk</span><br><span class="line">  #header: source/_data/header.njk</span><br><span class="line">  #sidebar: source/_data/sidebar.njk</span><br><span class="line">  #postMeta: source/_data/post-meta.njk</span><br><span class="line">  postBodyEnd: source/_data/post-body-end.njk</span><br><span class="line">  #footer: source/_data/footer.njk</span><br><span class="line">  #footer: source/_data/footer.njk</span><br><span class="line">  #bodyEnd: source/_data/body-end.njk</span><br><span class="line">  #variable: source/_data/variables.styl</span><br><span class="line">  #mixin: source/_data/mixins.styl</span><br><span class="line">  #style: source/_data/styles.styl</span><br></pre></td></tr></table></figure>

<h2 id="8-5奖赏"><a href="#8-5奖赏" class="headerlink" title="8.5奖赏"></a>8.5奖赏</h2><p>进入主题配置文件<code>My-Blog/themes/主题名称/_config.yml</code>并进行如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reward_settings:</span><br><span class="line">  # If true, a donate button will be displayed in every article by default.</span><br><span class="line">  enable: true				# 是否开启奖赏功能</span><br><span class="line">  animation: true			# 动画</span><br><span class="line">  #comment: Buy me a coffee</span><br><span class="line"></span><br><span class="line"># 去粗话需要的支付方式前面的注释符号，并在My-Blog/themes/主题名称/source/images文件夹下放入对应的图片</span><br><span class="line">reward:	</span><br><span class="line">  #wechatpay: /images/wechatpay.png</span><br><span class="line">  #alipay: /images/alipay.png</span><br><span class="line">  #paypal: /images/paypal.png</span><br><span class="line">  #bitcoin: /images/bitcoin.png</span><br></pre></td></tr></table></figure>

<h2 id="8-6页面加载效果"><a href="#8-6页面加载效果" class="headerlink" title="8.6页面加载效果"></a>8.6页面加载效果</h2><p>进入主题配置文件<code>My-Blog/themes/主题名称/_config.yml</code>并进行如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pace:</span><br><span class="line">  enable: true</span><br><span class="line">  # 所有可选颜色:</span><br><span class="line">  # black | blue | green | orange | pink | purple | red | silver | white | yellow</span><br><span class="line">  color: black</span><br><span class="line">  # 所有可选主题:</span><br><span class="line">  # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span><br><span class="line">  # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span><br><span class="line">  theme: loading-bar</span><br></pre></td></tr></table></figure>

<h1 id="9-结束语"><a href="#9-结束语" class="headerlink" title="9.结束语"></a>9.结束语</h1><p>基于Hexo+Github搭建博客就讲到这，对于Next主题的美化其实还有很多内容，鉴于网上教程过多，这里就只列出一部分。总体来说，能够完成个人博客的搭建，我个人的所有需求基本满足，日后我会继续在这里更新我阅读的每一篇文献，希望有兴趣的朋友可以多多关注！</p>
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>本地差分隐私保护综述</title>
    <url>/post/b16e3800.html</url>
    <content><![CDATA[<h1 id="1-众包模式"><a href="#1-众包模式" class="headerlink" title="1.众包模式"></a>1.众包模式</h1><p>一个公司或机构把过去由员工执行的工作任务，以自由自愿的形式外包给非特定的，而且通常是大型的大众网络的模式</p>
<h1 id="2-隐私保护的目标"><a href="#2-隐私保护的目标" class="headerlink" title="2.隐私保护的目标"></a>2.隐私保护的目标</h1><p>在数据收集阶段引入隐私保护机制来降低并控制隐私泄露的风险，平衡隐私保护与数据可用性之间的关系，解决和完善针对不牺牲用户个人隐私的大数据分析问题和机制</p>
<span id="more"></span>

<h1 id="3-传统隐私保护算法的缺陷"><a href="#3-传统隐私保护算法的缺陷" class="headerlink" title="3.传统隐私保护算法的缺陷"></a>3.传统隐私保护算法的缺陷</h1><p>（1）集中存储模型下，非可信数据管理者使用户无法直接控制个人隐私数据（<code>DP</code>也存在这一问题）</p>
<p>（2）由于背景知识无法明确界定，基于等价类的隐私保护模型被迫随着新攻击技术的出现而不断被动调整（3）无法提供严格且有效的数学理论来证明其隐私保护水平，无法定量分析隐私泄露风险</p>
<p>（4）值得重视的是，即使被严格处理的数据也可能泄露用户隐私</p>
<h1 id="4-本地差分隐私保护（LDP）的优势"><a href="#4-本地差分隐私保护（LDP）的优势" class="headerlink" title="4.本地差分隐私保护（LDP）的优势"></a>4.本地差分隐私保护（LDP）的优势</h1><p>本地差分隐私保护可以在不需要信任第三方数据管理者的情况下，直接在本地将隐私数据加噪来保护个人信息不被泄露，同时从宏观角度保证数据收集者可正确地推断出群体统计信息</p>
<h1 id="5-LDP应用场景"><a href="#5-LDP应用场景" class="headerlink" title="5.LDP应用场景"></a>5.LDP应用场景</h1><p>（1）集值型流式频繁项集挖掘的Heavy Hitters估计</p>
<p>（2）众包模式下字符串边缘频率估计和联合概率估计</p>
<p>（3）针对智能设备的机器学习</p>
<h1 id="6-布鲁姆过滤器（Bloom-Filter）"><a href="#6-布鲁姆过滤器（Bloom-Filter）" class="headerlink" title="6.布鲁姆过滤器（Bloom Filter）"></a>6.布鲁姆过滤器（Bloom Filter）</h1><p>（1）定义：由一个超长的二进制位数组和一系列的哈希函数组成。二进制位数组初始值全部为0，当给定一个待查询的元素时，这个元素会被一系列哈希函数计算映射出一系列的值，所有的值在位数组的偏移量处置为1</p>
<img src="/post/b16e3800/1.png" class title="布鲁姆过滤器">

<p>（2）判断元素是否在集合中的方法：元素经过一系列哈希函数计算后得到所有的偏移位置，若这些位置全都为1，则判断这个元素在这个集合中，若有一个不为1，则判断这个元素不在这个集合中</p>
<p>（3）优点：节省空间，采用位数组，2的32次方&#x3D;4294967296 可以看到42亿长度的位数组占用4294967296&#x2F;8&#x2F;1024&#x2F;1024&#x3D;512MB 只需占用512MB的内存空间</p>
<p>（4）缺点：有一定的误判，有可能把不在这个集合中的误判为在这个集合中，因为另一个元素经过哈希后各个位置也可能为1</p>
<h1 id="7-差分隐私分类"><a href="#7-差分隐私分类" class="headerlink" title="7.差分隐私分类"></a>7.差分隐私分类</h1><p>根据其应用场景及针对数据处理和收集方式的不同，主要存在两种数据分布模型：</p>
<p>（1）集中式模型（分为交互式和非交互式框架），又称为可信管理者模型（<code>Trusted Curator</code>）：服务器端直接存储未处理的原始用户隐私数据，并经过隐私处理等方式后统一对外发布</p>
<p>（2）本地模型（<code>Local Model</code>）：服务器端只能收到用户加噪的数据；用户在向数据收集者发送个人数据前，先在本地加入满足差分隐私的噪声扰动，最后数据收集者根据收集到的噪声数据，从统计学的角度近似估计出用户群体的统计特性，而不是针对具体用户个体进行统计特性推断</p>
<h1 id="8-中位数机制（目前没弄懂）"><a href="#8-中位数机制（目前没弄懂）" class="headerlink" title="8.中位数机制（目前没弄懂）"></a>8.中位数机制（目前没弄懂）</h1><h1 id="9-本地差分隐私保护主要思想"><a href="#9-本地差分隐私保护主要思想" class="headerlink" title="9.本地差分隐私保护主要思想"></a>9.本地差分隐私保护主要思想</h1><p>（1）不能收集或拥有任何个人的精确信息</p>
<p>（2）可以推断出用户群体的泛化统计信息</p>
<h1 id="10-DP与LDP的区别"><a href="#10-DP与LDP的区别" class="headerlink" title="10.DP与LDP的区别"></a>10.DP与LDP的区别</h1><p>两者最重要的区别在于加入噪声扰动的时机不同</p>
<img src="/post/b16e3800/2.png" class title="DP与LDP区别">

<h1 id="11-本地模型下的数据分析流程"><a href="#11-本地模型下的数据分析流程" class="headerlink" title="11.本地模型下的数据分析流程"></a>11.本地模型下的数据分析流程</h1><p>每个本地用户用随机器Q扰乱个人数据v得到Z，数据收集者将其汇总得到S，最后进行数据分析；</p>
<p>拉普拉斯机制经常被用于本地模型中，常用于对数值型结果的隐私保护</p>


<h1 id="12-随机响应RR（Randomized-Response）"><a href="#12-随机响应RR（Randomized-Response）" class="headerlink" title="12.随机响应RR（Randomized Response）"></a>12.随机响应RR（Randomized Response）</h1><p>（1）应用：保护敏感话题调查参与者隐私，目前主流的本地差分隐私保护都是基于RR</p>
<p>（2）具体应用场景：每个人不是属于组A就是组B，问题是在不能确定具体个人属于哪组的前提下，估计组A中人数的比例</p>
<p>（3）RR的解决方案：随机选取n个人，随机设备 (可以是抛硬币、摸球模型)以概率P指向A，以概率(1 一p)指向B。在每轮调查中，受访者只需回答设备指向(调查者未知)的组别是否与其真正的组别一致(Yes或No)，这样便可以得到组A人数的最大似然估计</p>
<p>（4）随机响应的效果：实现了ε-LDP，其中ε&#x3D;ln(p&#x2F;(1-p))</p>
<p>（5）存在问题：现有的基于RR技术的LDP机制在数据挖掘中具有一定的局限性，只适用于用户数据类型为数值型或范围型， 而数据收集者的数据挖掘任务局限于基本统计，如计数或求中位值等</p>
<p>（6）RR技术及其改进模型在收集群体层面的统计数据而不泄露个体数据方面具有优越性能，目前已成为新的研究热点</p>
<h1 id="13-随机响应RR举例"><a href="#13-随机响应RR举例" class="headerlink" title="13.随机响应RR举例"></a>13.随机响应RR举例</h1><p>（1）问题：假设有<code>n</code>个用户，其中艾滋病患者的比例为<code>π</code>，我们希望对<code>π</code>进行统计。于是对目标用户发起问卷调查：“你是否为艾滋病患者？”显然，如果直接获得用户的相应数据进行统计，一旦数据泄露，那么用户隐私随即泄露。因此，我们假设存在一枚非均匀的硬币，其正面向上的概率为<code>p</code>，反面向上的概率为<code>1-p</code>。抛出该硬币，若正面向上，则回答真实答案，反面向上，则回答相反的答案。</p>
<p>（2）推导过程：</p>
<ol>
<li><p>（step 1）</p>
<p>理论上，<code>Pr[Xi=“是”]=πp+(1-π)(1-p)</code>，<code>Pr[Xi=“否”]=(1-π)p+π(1-p)</code>。直觉上，当<code>n</code>足够大时，设回答“是”的人数为<code>n1</code>，回答“否”的人数为<code>n2</code>。<code>Pr[Xi=“是”]=n1/n</code>，<code>Pr[Xi=“否”]=n2/n</code>。求解下面的二次方程即可获得<code>π</code>的值</p>
<img src="/post/b16e3800/4.png" class title="二次方程">

<p>但是，<code>上述的结果并非真实比例的无偏估计</code>，我们用极大似然估计(<code>Max Likehood Estimation</code>)对统计结果进行校正</p>
</li>
<li><p>（step 2）</p>
<p>首先构建最大似然函数：</p>
<img src="/post/b16e3800/5.png" class title="最大似然函数">

<p>对数似然函数为：</p>
<img src="/post/b16e3800/6.png" class title="对数似然函数">

<p>令</p>
<img src="/post/b16e3800/7.png" class title="求解对数似然函数">

<p>求解可得<code>π</code>的极大似然估计：</p>
<img src="/post/b16e3800/8.png" class title="最大似然估计">

<p>由此可得患有<code>HIV</code>的总人数为：</p>
<img src="/post/b16e3800/9.png" class title="求总人数"></li>
</ol>
<h1 id="14-LDP研究方向"><a href="#14-LDP研究方向" class="headerlink" title="14.LDP研究方向"></a>14.LDP研究方向</h1><p>（1）基于随机应答与<code>Bloom Filter</code>的编解码方式研究（<code>RAPPOR</code>）</p>
<p>（2）针对流式频繁项集挖掘<code>Heavy Hitters</code>挖掘</p>
<p>（3）针对智能终端的收集与机器学习</p>
<h1 id="1RAPPOR算法（Google-Chrome）"><a href="#1RAPPOR算法（Google-Chrome）" class="headerlink" title="1RAPPOR算法（Google Chrome）"></a>1RAPPOR算法（Google Chrome）</h1><p><code>RAPPOR</code>应答被定义为比特位字符串，每一 位都是对应用户端特性报告的逻辑谓词随机应答， 用来收集用户群体的数值和序数值的统计，可以提供<code>ln(3)</code>的差分隐私保护（因为是基于随机响应技术，根据<code>13.随机响应RR</code>可求得隐私预算）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：用户数据X，参数k(串长度)，h(Hash个数)，概率参数f、p、q</span><br><span class="line">输出：数据报告s</span><br><span class="line">算法流程：</span><br><span class="line">(1)信号处理。用BloomFilter中的h个哈希函数将X编码成长度为k的01串B。 </span><br><span class="line">(2)永久随机响应(PRR)。利用随机应答技术对B进行扰动得到永久随机响应B&#x27;。 </span><br><span class="line">(3)即时随机响应(IRR)。利用随机应答技术对B&#x27;进行二次扰动得到即时随机响应s。 </span><br><span class="line">(4)报文。把收集的报告s发送到服务器</span><br></pre></td></tr></table></figure>

<blockquote>
<p>RAPPOR在解码过程中结合成熟的假设检验、最小二乘求解和LASSO回归实现针对字符串抽样群体频率的高可用解码框架</p>
</blockquote>
<p>存在问题：</p>
<p>（1）使用RAPPOR的数据收集者只能孤立地了解单一变量的分布。实际上，研究多个变量之间的关联更有意义</p>
<p>（2）数据收集者必须事先知道潜在字符串字典、安装软件的报告、名称、hash值，然而这些是不可能作为先验知识的</p>
]]></content>
      <categories>
        <category>差分隐私（中文综述）</category>
      </categories>
      <tags>
        <tag>差分隐私</tag>
      </tags>
  </entry>
  <entry>
    <title>AHEAD: Adaptive Hierarchical Decomposition for Range Query under Local Differential Privacy</title>
    <url>/post/8d2d0774.html</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>为了保护用户的隐私数据，人们使用本地差分隐私（<code>LDP</code>）提供支持隐私保护的范围查询，并支持进一步的统计分析。然而，现有的基于<code>LDP</code>的范围查询方法受限于其属性。而这种静态框架在低隐私预算场景下会带来过量的噪声。因此，提出了<code>AHEAD（Adaptive Hierarchical Decomposition）</code>方案，它可以自适应且动态地控制树的结构，进而注入的噪声可以得到较好地控制。</p>
<span id="more"></span>

<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><h2 id="1-1DP和LDP的执行流程"><a href="#1-1DP和LDP的执行流程" class="headerlink" title="1.1DP和LDP的执行流程"></a>1.1DP和LDP的执行流程</h2><p><code>DP</code>：一个可信的中心聚合器从用户端收集到敏感数据，然后再执行扰动分析，最后通过回答查询或者发布合成数据来提供数据服务；</p>
<p><code>LDP</code>：用户首先在本地对自己的隐私数据进行编码和扰动，然后再将处理过后的数据传输给聚合器。</p>
<h2 id="1-2LDP的研究"><a href="#1-2LDP的研究" class="headerlink" title="1.2LDP的研究"></a>1.2LDP的研究</h2><p><code>频率估计问题（Frequency Oracle）</code>（即获得整个域的频率分布）是<code>LDP</code>过去的主要研究内容，然而实际上人们可能对范围查询更加感兴趣。而且，根据范围查询结果，我们可以直接获得其他分布特征（如顺序统计量）；</p>
<p><code>顺序统计量</code>：在一个由<code>n</code>个元素组成的集合中，第<code>i</code>个顺序统计量即为该集合中第<code>i</code>小的元素。</p>
<h2 id="1-3范围查询"><a href="#1-3范围查询" class="headerlink" title="1.3范围查询"></a>1.3范围查询</h2><p>范围查询根据查询维度可以划分为低维度查询（维度小于等于2）和高维度查询（维度大于等于2）：</p>
<p><code>低维度查询</code>：王等人提出了基于完全B叉树结构分层分解整个域并且通过累积频率值来回答范围查询；Cormode等人提出在扰动的时候使用离散小波变换将用户的隐私值转化为一个哈尔变化系数向量并且执行其逆变换得到查询结果；</p>
<h3 id="1-3-1离散小波变换（待续）"><a href="#1-3-1离散小波变换（待续）" class="headerlink" title="1.3.1离散小波变换（待续）"></a>1.3.1离散小波变换（待续）</h3><h3 id="1-3-2哈尔小波变换（待续）"><a href="#1-3-2哈尔小波变换（待续）" class="headerlink" title="1.3.2哈尔小波变换（待续）"></a>1.3.2哈尔小波变换（待续）</h3><p><code>高维度查询</code>：杨等人提出从一二维网格组合信息，并且使用加权更新策略去估计高纬度的范围查询。</p>
<h2 id="1-4现有的方法存在的限制"><a href="#1-4现有的方法存在的限制" class="headerlink" title="1.4现有的方法存在的限制"></a>1.4现有的方法存在的限制</h2><p>大多数真实世界数据集中的数据域中存在<code>稀疏区域</code>（也就是某些区间的比重可能非常小），因此在网格或完全树中的值较小的结点可能被注入的噪声淹没；</p>
<p>现有的科技主要为具体维度的查询而设计（而实际数据集是经常变化的）（可以理解为都是<code>静态框架</code>），虽然每一种方法技术上不受查询维度的限制，但是在非目标维度的情况下有效性会降低，为了解决维度变化问题，聚合器需要组合为不同维度设计的算法，而这会限制这些算法的适用性和实用性。</p>
<h2 id="1-5文章的贡献"><a href="#1-5文章的贡献" class="headerlink" title="1.5文章的贡献"></a>1.5文章的贡献</h2><p>提出了一种在<code>LDP</code>下解决范围查询的动态算法<code>AHEAD</code>，它可以自适应地觉得域组合的粒度大小；</p>
<p>理论上推导了在满足严格的<code>LDP</code>保证下能实现高效用的参数设置；</p>
<p>通过大量实验证实了<code>AHEAD</code>算法的有效性。</p>
<h1 id="2-背景"><a href="#2-背景" class="headerlink" title="2.背景"></a>2.背景</h1><h2 id="2-1频率估计（Frequency-Oracle）"><a href="#2-1频率估计（Frequency-Oracle）" class="headerlink" title="2.1频率估计（Frequency Oracle）"></a>2.1频率估计（Frequency Oracle）</h2><p>频率估计是用来估计某个隐私属性的频率分布F，作为一般<code>LDP</code>任务（<code>边际释放</code>和<code>范围查询</code>）的基本构建块。大部分<code>FO</code>算法包括三部分：编码、扰动和聚合。</p>
<h2 id="2-2两种FO协议（GRR和OUE）"><a href="#2-2两种FO协议（GRR和OUE）" class="headerlink" title="2.2两种FO协议（GRR和OUE）"></a>2.2两种FO协议（GRR和OUE）</h2><h3 id="2-2-1广义随机响应（Generalized-Randomized-Response-GRR）"><a href="#2-2-1广义随机响应（Generalized-Randomized-Response-GRR）" class="headerlink" title="2.2.1广义随机响应（Generalized Randomized Response, GRR）"></a>2.2.1广义随机响应（Generalized Randomized Response, GRR）</h3><blockquote>
<p>Ps：随机响应算法的广义版本，目前我理解的是先对隐私数据进行扰动再进行编码</p>
</blockquote>
<p><code>编码</code>：对于用户<code>i</code>的隐私数据<code>Vi</code>，将其编码为<code>Xi</code>；</p>
<p><code>扰动</code>：用户<code>i</code>以根据以下式子选择<code>Vi</code>的值，并将扰动后的隐私值对应的编码<code>Xi&#39;</code>上传到服务器（其中<code>Vi&#39;</code>是从数据集<code>D</code>中随机选择）；</p>
<img src="/post/8d2d0774/1.png" class title="广义随机响应">

<p><code>聚合</code>：聚合器首先收集所有经过用户扰动之后的数据，然后计算每个数据<code>V</code>的频率<code>count[V]</code>，<code>count[V]</code>的一个无偏估计为：</p>
<img src="/post/8d2d0774/2.png" class title="&#96;count[V]&#96;的无偏估计">

<p><code>估计误差</code>：<code>GRR</code>的估计误差源自算法方差：</p>
<img src="/post/8d2d0774/3.png" class title="GRR算法方差">

<h3 id="2-2-2优化的一元编码（Optimized-Unary-Encoding-OUE）"><a href="#2-2-2优化的一元编码（Optimized-Unary-Encoding-OUE）" class="headerlink" title="2.2.2优化的一元编码（Optimized Unary Encoding, OUE）"></a>2.2.2优化的一元编码（Optimized Unary Encoding, OUE）</h3><blockquote>
<p>Ps：<code>RAPPOR</code>算法的优化版本</p>
</blockquote>
<p><code>编码</code>：对于用户<code>i</code>的隐私数据<code>Vi</code>，采用<code>独热编码</code>的方式将其编码为一个长为长度<code>|D|</code>的向量，其中<code>Vi</code>数据对应向量的第<code>i</code>个值为<code>1</code>，其余均为<code>0</code>；</p>
<h4 id="2-2-2-1One-Hot-Encoding（独热编码）"><a href="#2-2-2-1One-Hot-Encoding（独热编码）" class="headerlink" title="2.2.2.1One-Hot Encoding（独热编码）"></a>2.2.2.1One-Hot Encoding（独热编码）</h4><p><code>One-Hot编码</code>，又称为一位有效编码，即采用<code>N</code>个独立的寄存器对<code>N</code>个状态进行编码，对于每个状态，只有一个寄存器的值为<code>1</code>，其余寄存器的值都为<code>0</code></p>
<p><code>扰动</code>：对上一步得到的每个数据都采用<code>GRR</code>方法进行扰动，具体对每个数据的每一位来说，如果该位为<code>1（0）</code>，则以概率<code>p（q）</code>保持不变，以概率<code>1-p（1-q）</code>进行反转，然后用户将扰动后的编码<code>Xi&#39;</code>传输到服务器</p>
<p><code>聚合</code>：聚合器收集到所有经过用户扰动后的数据，然后对每一位为1的个数进行频率统计得到<code>count[V]</code>，<code>count[V]</code>的一个无偏估计为：</p>
<img src="/post/8d2d0774/2.png" class title="&#96;count[V]&#96;的无偏估计">

<p><code>估计误差</code>：算法方差为：</p>
<img src="/post/8d2d0774/4.png" class title="算法方差">

<blockquote>
<p>总结：可以看到，<code>GRR</code>和<code>OUE</code>算法都得到了频率值的无偏估计，而且，<code>OUE</code>算法的方差独立于数据集大小<code>|D|</code>。所以对于更小的<code>|D|</code>，<code>GRR</code>算法更好；而对于更大的<code>|D|</code>，<code>OUE</code>算法更好</p>
</blockquote>
<h1 id="3-现有的解决方案（针对范围查询问题）"><a href="#3-现有的解决方案（针对范围查询问题）" class="headerlink" title="3.现有的解决方案（针对范围查询问题）"></a>3.现有的解决方案（针对范围查询问题）</h1><h2 id="3-1Hierarchical-Interval-Optimized（HIO）"><a href="#3-1Hierarchical-Interval-Optimized（HIO）" class="headerlink" title="3.1Hierarchical-Interval Optimized（HIO）"></a>3.1Hierarchical-Interval Optimized（HIO）</h2><h3 id="3-1-1算法描述"><a href="#3-1-1算法描述" class="headerlink" title="3.1.1算法描述"></a>3.1.1算法描述</h3><p>基于<code>B</code>叉树，<code>HIO</code>算法将整个域分层分解为相互不相交的子集称为<code>区间</code>。根节点代表整个域，叶节点代表单个的值，其中相同层的结点代表相同粒度的<code>区间</code>。<code>HIO</code>算法通过<code>OUE</code>算法获得每一层结点的频率估计值，且通过使用最少的来自不同层的区间来回答范围查询。</p>
<blockquote>
<p>对于范围长度为<code>r</code>的一般查询，<code>HIO</code>算法最多需要2（B-1）log<sub>B</sub>|D|个区间进行回答</p>
</blockquote>
<h3 id="3-1-2算法不足"><a href="#3-1-2算法不足" class="headerlink" title="3.1.2算法不足"></a>3.1.2算法不足</h3><p>在所有区间的估计频率值中插入了相同级别的噪声，对于小区间的结点，扰动噪声可能会淹没真实的频率值，进而降低了整个算法的有效性；</p>
<p>在多维度场景中，树的层数随着维度的变化呈指数级增长；</p>
<p>在高维度场景中，查询误差因为小区间的结点数量过多，查询误差会不断增加。</p>
<h2 id="3-2Discrete-Haar-Wavelet-Transform（DHT）"><a href="#3-2Discrete-Haar-Wavelet-Transform（DHT）" class="headerlink" title="3.2Discrete Haar Wavelet Transform（DHT）"></a>3.2Discrete Haar Wavelet Transform（DHT）</h2><h3 id="3-2-1算法描述"><a href="#3-2-1算法描述" class="headerlink" title="3.2.1算法描述"></a>3.2.1算法描述</h3><p><code>DHT</code>算法对于整个域采用采用完全二叉树结构，并且把用户的隐私数据编码为一个<code>哈尔小波系数集合</code>。</p>
<blockquote>
<p>对于范围长度为<code>r</code>的查询，<code>DHT</code>算法比起直接采用<code>FO</code>算法能够在哈尔变换域中使用更少数量的估计值</p>
</blockquote>
<h3 id="3-2-2算法不足"><a href="#3-2-2算法不足" class="headerlink" title="3.2.2算法不足"></a>3.2.2算法不足</h3><p>与<code>HIO</code>算法相似，在所有区间的估计频率值中插入了相同级别的噪声，对于小区间的结点，扰动噪声可能会淹没真实的频率值，进而降低了整个算法的有效性；</p>
<p>主要针对一维场景设计，因此限制了其实际的应用场景。</p>
<h2 id="3-3Consistent-Adaptive-Local-Marginal（CALM）"><a href="#3-3Consistent-Adaptive-Local-Marginal（CALM）" class="headerlink" title="3.3Consistent Adaptive Local Marginal（CALM）"></a>3.3Consistent Adaptive Local Marginal（CALM）</h2><h3 id="3-3-1列联表（Contingency-table）"><a href="#3-3-1列联表（Contingency-table）" class="headerlink" title="3.3.1列联表（Contingency table）"></a>3.3.1列联表（Contingency table）</h3><p><code>列联表</code>是观测数据按两个或更多属性（定性变量）分类时所列出的频数表，是由两个以上的变量进行交叉分类的频数分布表，其分析的<code>基本问题</code>是判明所考察的个属性之间有无关联（即是否独立）。若所考虑的属性多于两个则称为<code>多维列联表</code>。如果考虑集合的全部属性，则称为<code>全列联表</code>；如果考虑集合的部分属性，则称为<code>边缘列联表</code>。若考虑集合的属性个数为k，则称为<code>k-路边缘列联表</code>。</p>
<blockquote>
<p>Ps：全列联表就是联合概率密度分布，边缘列联表就是边缘概率密度分布</p>
</blockquote>
<h3 id="3-3-2算法描述（有点复杂，待续）"><a href="#3-3-2算法描述（有点复杂，待续）" class="headerlink" title="3.3.2算法描述（有点复杂，待续）"></a>3.3.2算法描述（有点复杂，待续）</h3><p><code>CALM</code>算法是一种满足<code>LDP</code>定义的<code>边缘列联表发布（Marginal Release）</code>方案，它可以在隐私保护保证的背景下构建<code>m</code>个属性的列联表。该算法使用对重构的被包含在查询中的列联表进行求和来对范围查询进行回答。</p>
<h3 id="3-3-3算法不足"><a href="#3-3-3算法不足" class="headerlink" title="3.3.3算法不足"></a>3.3.3算法不足</h3><p>当数据集大小<code>|D|</code>很大时，<code>CALM算法</code>在回答一个查询时会加入大量的加噪列联表，而这很可能会给真实值注入大量的噪声。</p>
<h2 id="3-4Hybird-Dimensional-Grids（HDG）"><a href="#3-4Hybird-Dimensional-Grids（HDG）" class="headerlink" title="3.4Hybird-Dimensional Grids（HDG）"></a>3.4Hybird-Dimensional Grids（HDG）</h2><h3 id="3-4-1算法描述"><a href="#3-4-1算法描述" class="headerlink" title="3.4.1算法描述"></a>3.4.1算法描述</h3><p>仔细地将属性对的二维域都划分到粗的二维网格中，并且从相关的二维范围查询的答案中估计更高维度范围查询的结果。为了捕获用户数据的细颗粒分发信息，<code>HDG算法</code>还引入了一维网格去提供每个属性上的细粒度分发信息，并将来自一维和二维网格信息结合在一起去回答范围查询。</p>
<h3 id="3-4-2算法不足"><a href="#3-4-2算法不足" class="headerlink" title="3.4.2算法不足"></a>3.4.2算法不足</h3><p>相同粒度的网格不能处理用户数据的各种分布；</p>
<p>使用一维网格可能会破坏属性之间的相关性。</p>
<h2 id="3-5附注"><a href="#3-5附注" class="headerlink" title="3.5附注"></a>3.5附注</h2><h3 id="3-5-1设计目标"><a href="#3-5-1设计目标" class="headerlink" title="3.5.1设计目标"></a>3.5.1设计目标</h3><p>为整个域找到一个合理的分解策略去避免引入过量的噪声；</p>
<p>在拓展到多维场景时，设计的机制应该要比现有算法的有更高的查询精确度。</p>
<h3 id="3-5-2与现有算法的不同之处"><a href="#3-5-2与现有算法的不同之处" class="headerlink" title="3.5.2与现有算法的不同之处"></a>3.5.2与现有算法的不同之处</h3><p><code>AHEAD算法</code>是自适应且动态的算法；</p>
<p><code>AHEAD算法</code>减少了噪声对小区间结点的影响；</p>
<p><code>AHEAD算法</code>可以从一维拓展到高维场景中。</p>
<h1 id="4-AHEAD算法"><a href="#4-AHEAD算法" class="headerlink" title="4.AHEAD算法"></a>4.AHEAD算法</h1><h2 id="4-1动机和概述"><a href="#4-1动机和概述" class="headerlink" title="4.1动机和概述"></a>4.1动机和概述</h2><p>一方面，当回答查询需要结合多个小区间结点时，因为每个区间结点都需要满足LDP的隐私保证，所以都会引入噪声，当小区间结点过多时注入的噪声就会更加地多，为了解决这一问题，因此需要动态地结合不同的区间结点，进而减少注入的噪声量；</p>
<p>另一方面，当查询的范围是某个区间的一部分时，此时需要采用主流的均匀分布假设来回答查询，这时如果区间内分布不均匀就会引入不均匀误差；</p>
<p>综上分析，AHEAD算法应该试图平衡这两种误差，并解决现有算法的不足。</p>
<h2 id="4-2工作流程"><a href="#4-2工作流程" class="headerlink" title="4.2工作流程"></a>4.2工作流程</h2><h3 id="4-2-1采样方案的选择（Sampling-Principle）"><a href="#4-2-1采样方案的选择（Sampling-Principle）" class="headerlink" title="4.2.1采样方案的选择（Sampling Principle）"></a>4.2.1采样方案的选择（Sampling Principle）</h3><p>使用隐私预算时有两种策略：<code>隐私预算拆分策略</code>和<code>用户分区策略</code></p>
<p><code>隐私预算拆分策略（privacy budget splitting strategy）</code>：将整个隐私预算<code>𝜖</code>分成<code>c</code>份，并且在隐私预算<code>𝜖/c</code>下对所有用户的报告进行频率分布的估计；</p>
<p><code>用户分区策略（user partition strategy）</code>：随机地将用户分为<code>c</code>组，并使用整个隐私预算从魅族用户那里获取频率值；</p>
<p>对于相同的区间结点，两种策略的方差分别如下所示：</p>
<img src="/post/8d2d0774/5.png" class title="隐私预算拆分策略方差">

<img src="/post/8d2d0774/6.png" class title="用户分区策略方差">

<p>因为<code>𝜖&gt;0</code>且<code>c&gt;1</code>，所以<code>Var1&gt;Var2</code></p>
<blockquote>
<p>Ps：这两个方差的大小比较还没弄明白（待续）</p>
</blockquote>
<p>综上，<code>AHEAD算法</code>选择了<code>用户分区策略（user partition strategy）</code>。</p>
<h3 id="4-2-2算法流程"><a href="#4-2-2算法流程" class="headerlink" title="4.2.2算法流程"></a>4.2.2算法流程</h3><p><code>Step1：User Partition</code>：聚合器首先确定用户分区数量<code>c</code>，其中<b>c&#x3D;log<sub>B</sub>|D|</b>，然后用户在<code>[1, 2, ... , c]</code>中随机选择一个分区号（用户也可以使用其公共信息去选择分区号）。分区过程应该确保每个分区拥有相似的用户数量去代表总体人口；</p>
<p><code>Step2：Noisy Frequency Construction</code>：聚合器首先创建一个根节点<b>n<sub>0</sub></b>代表整个域，然后聚合器对整个域执行初始分解（即把整个域分解成<code>B</code>个大小相等的区间，<code>B</code>是树的分支数），并将分解得到的区间结点指向根节点<code>n&lt;sub&gt;0&lt;/sub&gt;</code>，此时根节点<code>n&lt;sub&gt;0&lt;/sub&gt;</code>的子结点代表整个域的划分方式<b>E<sub>1</sub></b>。之后聚合器选择第一个分区的用户并将<b>E<sub>1</sub></b>和隐私预算<code>𝜖</code>发送给用户。这时第一个分区的用户就会先扰动自己的隐私数据，并将扰动值通过<code>OUE</code>算法投入到<b>E<sub>1</sub></b>划分后得到的区间中。聚合器在收到用户的数据后就会使用聚合算法去获得频率估计分布<b>F<sub>1</sub></b>；</p>
<p><code>Step3：New Decomposition Generation</code>：聚合器得到区间的频率估计分布<b>F<sub>1</sub>&#x3D;{f<sub>1</sub>, f<sub>2</sub>}</b>之后，会根据阈值θ决定是否要对区间结点进一步分解。具体来说，如果某个频率<code>f</code>小于阈值<code>θ</code>，则不需要再进行分解；如果某个频率<code>f</code>大于阈值<code>θ</code>，则需要对该区间再次进行分解得到划分方式<b>E<sub>2</sub></b>并处理下一组用户；聚合器重复以上步骤知道所有的用户数据都已经处理完毕。在构造上述的原型树时没有考虑书中频率值的约束（子结点的频率值总和等于父节点的频率值），因此需要进行后处理；</p>
<p><code>Step4：Post-processing</code>：该步骤包含<code>非负</code>和<code>加权平均</code>（可以最大程度减少噪声的幅度）两步操作。<code>AHEAD算法</code>首先在相同层中通过<code>NormSub算法</code>使得结点的估计频率值都非负，且所有频率值的总和为<code>1</code>；然后自底向上计算非叶节点<code>n</code>和其子结点的加权平均值去更新<code>n</code>的频率估计值（通过结合<code>n</code>的多次估计来减少加性噪声）：</p>
<blockquote>
<p>对于非根节点<code>n</code>：</p>
<img src="/post/8d2d0774/8.png" class title="结点频率值更新">

<p>其中，参数设置如下（这样设置可以得到最小的更新方差）：</p>
<img src="/post/8d2d0774/9.png" class title="参数&lt;b&gt;𝜆&lt;sub&gt;1&lt;&#x2F;sub&gt;&lt;&#x2F;b&gt;">

<img src="/post/8d2d0774/10.png" class title="参数&lt;b&gt;𝜆&lt;sub&gt;2&lt;&#x2F;sub&gt;&lt;&#x2F;b&gt;">

<p>Var<sub>child(n)</sub>代表结点<code>n</code>的子结点的方差总和，Var<sub>n</sub>代表结点<code>n</code>的方差。<code>f~</code>代表<code>f^</code>的后处理版本</p>
</blockquote>
<blockquote>
<p>定理：使用上述方程对子结点进行组合时，结点<code>n</code>可以获得最小的更新方差</p>
<p>证明：（待续）</p>
</blockquote>
<p>最后，在结点区间均匀分布的假设下，自顶向下对频率值进行迭代分解以获得一颗用于回答范围查询的完全树，至此，<code>AHEAD算法</code>结束。</p>
<h2 id="4-3隐私和效用分析"><a href="#4-3隐私和效用分析" class="headerlink" title="4.3隐私和效用分析"></a>4.3隐私和效用分析</h2><h3 id="4-3-1隐私保证"><a href="#4-3-1隐私保证" class="headerlink" title="4.3.1隐私保证"></a>4.3.1隐私保证</h3><p><code>定理</code>：<code>AHEAD算法</code>满足<code>𝜖-LDP</code></p>
<p><code>证明</code></p>
<p><code>Step1</code>中，用户在<code>[1, 2, ... , c]</code>中随机地选取其分区，这一步没有隐私预算消耗；<code>Step2</code>和<code>Step3</code>中，<code>AHEAD算法</code>顺序地与用户进行交互，并且每个用户产生一个输出；<code>Step4</code>中，AHEAD算法没有触及用户地隐私数据，因此不会产生额外地隐私预算；因此，如果在和用户交互时（<code>Step3</code>和<code>Step4</code>）满足<code>𝜖-LDP</code>，那么<code>AHEAD算法</code>满足<code>𝜖-LDP</code>；</p>
<p>在每个交互时回合中，<code>AHEAD算法</code>都基于<code>Step2</code>中的隐私预算<code>𝜖</code>使用<code>OUE算法</code>构建嘈杂的频率；对于分区<code>g</code>中同一用户的任何一对可能值<b>v<sub>1</sub>, v<sub>2</sub>∈D</b>，加噪的二进制向量<code>O</code>为<code>OUE</code>范围内的潜在输出；</p>
<img src="/post/8d2d0774/11.png" class title="&#96;𝜖-LDP&#96;证明">

<p>上式中<code>l</code>是<code>O</code>的长度。根据上式可知，Step2满足<code>𝜖-LDP</code>，而由于<code>Step3</code>处理的是用户上传的加噪之后的数据（即没有使用用户原始的隐私数据），所以没有消费额外的隐私预算消费；</p>
<p>综上，<code>AHEAD算法</code>满足<code>𝜖-LDP</code></p>
<h3 id="4-3-2误差分析"><a href="#4-3-2误差分析" class="headerlink" title="4.3.2误差分析"></a>4.3.2误差分析</h3><p><code>AHEAD算法</code>的误差来源有三个：<code>噪声</code>、<code>采样误差</code>、<code>不均匀误差</code></p>
<p><code>噪声</code>和<code>采样误差</code>：来自<code>OUE</code>扰动和用户采样过程。虽然<code>OUE</code>算法可以得到频率估计值的无偏估计，但是仍然会存在由扰动导致的估计方差，而据研究分析，采样误差是一个远小于注入噪声的常数；</p>
<p><code>不均匀误差</code>：来自于一些区间，其频率值要通过较大的区间（父节点）来获得，而父节点并不一定满足均匀分布假设</p>
<p>综上，<code>AHEAD算法</code>的主要误差为<code>噪声</code>和<code>不均匀误差</code></p>
<h2 id="4-4B和θ的选择"><a href="#4-4B和θ的选择" class="headerlink" title="4.4B和θ的选择"></a>4.4B和θ的选择</h2><h3 id="4-4-1θ的选择"><a href="#4-4-1θ的选择" class="headerlink" title="4.4.1θ的选择"></a>4.4.1θ的选择</h3><p><code>θ</code>遵循以下式子进行设置：</p>
<img src="/post/8d2d0774/12.png" class title="&#96;θ&#96;的选择">

<img src="/post/8d2d0774/13.png" class title="&#96;Var&#96;">

<p><code>分析</code></p>
<p>首先使用在<code>HIO算法</code>中使用的策略去获得频率估计值和整体估计误差的期望，具体计算如下：</p>
<img src="/post/8d2d0774/14.png" class title="&#96;HIO算法&#96;误差">

<p>然后使用在<code>AHEAD算法</code>去获得整体估计误差的期望，具体计算如下：</p>
<img src="/post/8d2d0774/15.png" class title="&#96;AHEAD算法&#96;误差">

<p>然后令<code>AHEAD算法</code>的误差小于<code>HIO算法</code>的误差，得到以下不等式：</p>
<img src="/post/8d2d0774/16.png" class title="推导结果">

<p>综上，使用上述式子对<code>θ</code>进行设置时可以更好地减小估计误差</p>
<h3 id="4-4-2B的选择"><a href="#4-4-2B的选择" class="headerlink" title="4.4.2B的选择"></a>4.4.2B的选择</h3><p>分支因数<code>B</code>的作用在于平衡树的高度和回答查询需要的结点数量，<code>AHEAD算法</code>在考虑了不均匀误差的基础上将<code>B</code>设置为<code>2</code></p>
<p><code>分析</code></p>
<p>因为对数据的分布没有先验知识，所以对于不均匀误差应该考虑最坏情况，此时估计误差的期望为：</p>
<img src="/post/8d2d0774/17.png" class title="估计误差期望">

<p>对上式进行求导并另导函数为<code>0</code>，得到<code>B=0.6</code>或<code>B=2.2</code>。因为分支因数为大于<code>1</code>的整数，并且<code>B=2</code>比<code>B=3</code>的期望更小，所以最终设置<code>B=2</code></p>
<h2 id="4-5拓展到多维场景"><a href="#4-5拓展到多维场景" class="headerlink" title="4.5拓展到多维场景"></a>4.5拓展到多维场景</h2><h3 id="4-5-1二维范围查询"><a href="#4-5-1二维范围查询" class="headerlink" title="4.5.1二维范围查询"></a>4.5.1二维范围查询</h3><p>对于<code>AHEAD算法</code>，一维和二维的主要区别在于分解过程：对于一维场景，分解的总区间为<code>[1, |D|]</code>；对于二维场景，分解的总区间为<code>[1, |D|]x[1, |D|] </code>；</p>
<p>对于二维场景，<code>AHEAD算法</code>将<code>B</code>设置为<code>4</code>（每个维度的<code>B=2</code>），其具体的工作流程与一位范围查询基本相同。而为了减小随着结点使用数量不断增加而增加的查询误差，<code>AHEAD算法</code>更偏向于使用粗粒结点来回答查询（即自顶向下）</p>
<h3 id="4-5-2高维范围查询"><a href="#4-5-2高维范围查询" class="headerlink" title="4.5.2高维范围查询"></a>4.5.2高维范围查询</h3><p>AHEAD算法可以通过两种方式拓展到更高维度：<code>Direct Estimation</code>、<code>Leveraging Low-dimensional Estimation</code></p>
<p><code>Direct Estimation</code>：对于一颗分支因数为B&#x3D;2<sup>m</sup>的树，<code>AHEAD算法</code>同时在<code>m</code>个维度进行分解；该方法的不足在于随着维度的不断增加，叶节点的数量呈指数级增长，这使得对高维度数据集进行范围查询处理时变得相当耗时；</p>
<p><code>Leveraging Low-dimensional Estimation</code>：该算法对用户数据的数量进行结对组合，并对每一对属性对构建一颗二维<code>AHEAD树</code>；当回答一个<code>m</code>维的范围查询时，<code>LLE</code>构建了一个带有关联<b>2<sup>m</sup></b>个查询的查询集合，然后，以二维频率作为限制，<code>LLE</code>通过最大熵优化估算所有<b>2<sup>m</sup></b>个查询的频率值</p>
<blockquote>
<p><code>最大熵优化估算</code>：（待续）</p>
</blockquote>
<p>综上，<code>DE</code>方法的实现相对简单，并且用户分区的数量不会随维度的增加而增加。但是，在高维场景中，使用<code>DE</code>的<code>AHEAD树</code>可能非常大，这会使树的构造和进行范围查询的过程变得相当耗时。与<code>DE</code>相比，<code>LLE</code>将属性成对结合在一起，然后为每个属性对构造一个二维<code>AHEAD树</code>，这会使每棵树的规模都不太大。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h1><p>通过利用自适应层次分解，为一维和多维范围查询问题提出了一种新颖的<code>LDP</code>协议。<code>AHEAD算法</code>满足了严格的<code>LDP</code>保证，同时使用理论上衍生的参数实现了有利的实用性性能。通过理论分析以及广泛的实验评估，文章展示了<code>AHEAD算法</code>在范围查询方面平衡效用和隐私性的有效性及其在最新方法中的显着优势。此外，通过研究各种参数设置，文章得出了几种在实践中采用的重要观察。</p>
]]></content>
      <categories>
        <category>差分隐私（英文文献）</category>
      </categories>
      <tags>
        <tag>差分隐私</tag>
        <tag>频率估计</tag>
        <tag>边缘列联表发布</tag>
        <tag>Range Query</tag>
      </tags>
  </entry>
  <entry>
    <title>Implementing the Exponential Mechanism with Base-2 Differential Privacy</title>
    <url>/post/b63ba420.html</url>
    <content><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>现如今差分隐私有很好的理论支持，但是实现却仍是一个挑战，因为差分隐私的理论机制是任意或无限精度的，而在差分隐私具体的实现过程中采用的却是浮点或者固定精度。显然，差分隐私从理论到实际的这一转换过程肯定会存在一些问题，而这一点可能会成为攻击者实施攻击的一种手段。本文提出的方法将差分隐私定义中的基数e转换成基数2，而因为计算机是二进制的，这样转换之后就可以精确地执行算法，且时空复杂度较低。</p>
<span id="more"></span>

<h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>首先介绍了差分隐私理论（一个理论上十分严格的隐私框架，要求同一查询对邻近数据库的结果不可区分）（邻近数据库：两个数据库之间只相差一个条目）的提出背景；</p>
<p><code>差分隐私的定义源自</code>：KL散度，最大散度，<em>δ</em>-近似最大散度</p>
<p>差分隐私可以保证数据库中每个个体的隐私，并且对于与其他隐私机制的后处理也是健壮的；但是构建DP系统或机制可能具有挑战性，像拉普拉斯这类的添加噪声的机制容易受到机制规范和有限精度算法之间的转换问题的影响，而且在有限精度值上添加不精确计算产生的噪声可能会泄露原始值的重要信息。</p>
<p><code>指数机制</code>：不同于拉普拉斯机制，指数机制从一个固定的公共已知结果集中采样，选择每个结果的概率与一个由隐私数据决定的效用值u成比例。人们最初认为该机制不会受到基于浮点的攻击，然而一种基于不精确的浮点算术攻击可能对该机制造成影响。因此本文提出将e作为基数转换到2为基数，然后阐述了本文的核心概念贡献和主要技术贡献。</p>
<h5 id="1-1差分隐私初步"><a href="#1-1差分隐私初步" class="headerlink" title="1.1差分隐私初步"></a>1.1差分隐私初步</h5><p>引用前人提出的纯差分隐私，敏感度和拉普拉斯机制，指数机制等相关概念；</p>
<p>Note: 为了实现拉普拉斯机制，必须以任意精度从拉普拉斯分布中取样，而这在实践中肯定是有问题的，因为浮点数不能表示拉普拉斯分布中的每一个可能的值，而这可以被恶意方通过检查结果的最低位进行攻击，即这种攻击得以进行的原因是浮点计算的不精确导致对邻近数据库的查询结果是不同的，幸运的是，这种在拉普拉斯机制上的攻击可以通过细致的计算得到缓解。</p>
<h4 id="2-推翻指数机制"><a href="#2-推翻指数机制" class="headerlink" title="2.推翻指数机制"></a>2.推翻指数机制</h4><p>根据浮点数的IEEE表示阐明指数机制的简单实现如何被破坏：一种是不为0的两个很小的数相乘的结果下溢为0；另一种是数量级不同的两个数相加，因为较大的数要占据所有的精度位，所以较小的数被截断。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指数机制的python朴素实现</span></span><br><span class="line"><span class="comment"># Note: weights计算为什么多除了2; c_weights计算括号位置有问题</span></span><br><span class="line"><span class="comment"># The naive exponential mechanism</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># Inputs :</span></span><br><span class="line"><span class="comment"># eps : the privacy parameter ε</span></span><br><span class="line"><span class="comment"># u : the utility function 效用函数</span></span><br><span class="line"><span class="comment"># O : the set of outputs 输出结果集合</span></span><br><span class="line"><span class="comment"># Returns : an element in O 返回O中的一个元素</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">naive_exp_mech</span> (eps, u, O):</span><br><span class="line">	<span class="comment"># compute the weight of each element 计算每个元素的权重</span></span><br><span class="line">	weights = [np.exp(-(eps/<span class="number">2.0</span>) * u(o)) <span class="keyword">for</span> o <span class="keyword">in</span> O]</span><br><span class="line">    <span class="comment"># 计算总权重</span></span><br><span class="line">    T = <span class="built_in">sum</span>(weights)</span><br><span class="line">    <span class="comment"># cumulative weights 计算累积权重</span></span><br><span class="line">    c_weights = [<span class="built_in">sum</span>(weights [<span class="number">0</span>: i])/ T <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">1</span> , <span class="built_in">len</span> (O) +<span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># uniform sample from [0 ,1) 随机取出index</span></span><br><span class="line">    index = np.random.rand() </span><br><span class="line">    <span class="comment"># return element corresponding to the random index 根据随机取出的index返回元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">0</span>, <span class="built_in">len</span>(O)):</span><br><span class="line">    	<span class="keyword">if</span> c_weights[i] &gt; index :</span><br><span class="line">    		<span class="keyword">return</span> O[i]</span><br></pre></td></tr></table></figure>

<p><code>上述指数机制被破坏的两种场景转化位以下两种攻击方式</code></p>
<p><code>Zero-rounding</code></p>
<p>假设攻击者希望知道Alice是否在数据库中。攻击者选择一个结果空间O&#x3D;[O0, O1]，以及一个效用函数：如果Alice在数据库中，那么𝑢(𝑜0) &#x3D; 𝑥 且 𝑢(𝑜1) &#x3D; 𝑥 + 1；如果Alice不在数据库中，那么𝑢(𝑜0) &#x3D; 𝑥 + 1 且 𝑢(𝑜1) &#x3D; 𝑥。（以上场景中u的敏感度是1）。攻击者然后设置𝑥，使得np.exp(−(eps&#x2F;2) ∗ x) &gt; 0 但是np.exp(−(eps&#x2F;2) ∗ (x + 1)) &#x3D; 0。攻击者这样设置之后，如果Alice在数据库中，那么会得到结果O0的权重大于零，而结果O1的权重等于零，那么唯一可行结果就是O0；反之唯一可行结果就是O1。这样攻击者基本上可以确定Alice是否在数据库中。</p>
<p>Note：攻击者可以这样设置的原因就在于对x+1的权重进行计算时，计算出来的权重可能特别小以至于只能用0进行表示；而对x的权重进行计算时却正常</p>
<p>有人会说：只要保证所有元素的权值都大于零，那这种攻击就无效了</p>
<p><code>Truncated addition</code></p>
<p>攻击者选择两个值𝑥𝑙 和 𝑥𝑠，以及结果空间O&#x3D;[k]，使得XXX成立。攻击者然后选择一个效用函数使得：如果Alice不在数据库中，那么𝑢(𝑜1) &#x3D; 𝑥𝑙 + 1 且 𝑢(𝑜𝑖&gt;1) &#x3D; 𝑥𝑠；如果Alice在数据库中，那么𝑢(𝑜1) &#x3D; 𝑥𝑙 且 𝑢(𝑜𝑖&gt;1) &#x3D; 𝑥𝑠 +1。攻击者这样设置之后，如果Alice在数据库中，因为结果O1的概率非常的大，甚至等于总权重t，所以唯一可行结果就是O1。</p>
<p>Note：攻击者可以这样设置的原因就在于对𝑥𝑠 +1进行权重计算时，计算出来的权重比起𝑥𝑙计算出来的权重太小以至于可以忽略</p>
<p>一个解决办法：可以在机制执行的过程中监视每一次加法，但是这样的监视是非平凡的，因为e^x不能在有限位数内精确表达使得加法不能精确执行</p>
<p><code>缓解攻击方法一：将允许的效用值限制在一个范围内，使得在最小和最大可能权值内可以安全进行加法计算</code></p>
<p>但是要怎么把效用值限制在一个范围内？不精确的计算对隐私有什么影响？声明一个安全的范围确定的效用函数集的关键问题在于难以描述由于不精确计算带来的隐私损失，而且我们对实现的隐私损失作出的一般保证都是悲观的。</p>
<p><code>缓解攻击方法二：将分析限制在一组以前审查过的效用函数或工具上</code></p>
<p>但是即使是具有容易理解的灵敏度特性的简单小工具，例如标量乘法或加法，也可以用来构造上述攻击。</p>
<h4 id="3-精确实现指数机制"><a href="#3-精确实现指数机制" class="headerlink" title="3.精确实现指数机制"></a>3.精确实现指数机制</h4><p>针对上述问题，提出一个简单、精确的指数机制实现，并列出结果的四个贡献：</p>
<p>（1）定义base-2 DP，说明base-2和base-e之间的关系，并且证明当正确实现base-2指数机制时可以给出一个精确的隐私保证</p>
<p>（2）如何选择隐私参数和处理非整数效用函数（随机舍入），关键点在于随机舍入不会因为不精确的实现带来隐私损失，因为可以证明隐私损失原子最坏情况的舍入行为</p>
<p>（3）不使用除法从归一化概率中进行采样</p>
<p>（4）实现（python，Rust）</p>
<h5 id="3-1Base-2差分隐私"><a href="#3-1Base-2差分隐私" class="headerlink" title="3.1Base-2差分隐私"></a>3.1Base-2差分隐私</h5><p>这一动机源自观察，即计算机非常擅长于精确的二进制计算。本文不计算e^x，反之合适地选择一个y并计算2^y，使得从隐私角度能实现相同的结果，同时仍然能够利用精确的浮点运算。</p>
<p>根据Base-e差分隐私提出Base-2差分隐私（以及Base-2的指数机制），并阐明两者之间的关系：满足𝜂|2-DP的所有机制一定满足ln(2)𝜂−DP</p>
<h5 id="3-2非整数隐私参数和有效性（22-x2F-04-x2F-19-page5）"><a href="#3-2非整数隐私参数和有效性（22-x2F-04-x2F-19-page5）" class="headerlink" title="3.2非整数隐私参数和有效性（22&#x2F;04&#x2F;19 page5）"></a>3.2非整数隐私参数和有效性（22&#x2F;04&#x2F;19 page5）</h5><p><code>整数效用值情形下隐私参数的选择</code></p>
<p>第一，描述一个𝜂的大的集合（2^−𝜂可以精确计算）；第二，在这个集合中表达2^−𝜂的精度位数不会太大</p>
<p>对于一个二进制q和一个整数n，q^n最多需要max(1, bq<em>n)个精度位；因此对于2^(−𝜂) &#x3D; (x</em>2^(-y))^z，最多需要的精度位数为z*(y+bx)，所以对于(2^(−𝜂))^𝑢，最多需要的位数为max(1, u<em>z</em>(y+bx))</p>
<p>因为当设置z&#x3D;1且选择小的y时，𝜂的范围还是很大，所以实际上主要关注点就是𝑢的数量级，即控制精度的主要考虑时效用值的范围：自然的想法时直接给一个预规定的𝑢的一个可接受范围，并将观测到的效用值都限制到这个范围中（只要这个范围独立于隐私数据库，那么限制这个范围就不会给隐私保证带来影响）</p>
<p><code>确定最小精度的两种途径</code><br>（1）以给定的精度运行机制，如果执行的算法不精确，则以更高的精度重复该机制</p>
<p>（2）在运行机制前，对允许的效用值和结果空间大小使用公共指定边界，从而确定最小精度</p>
<p><code>第二种途径有两种方法</code><br>（1）最坏情况的理论分析：源自引理3.4，该引理得出最坏情况下计算权重组合所需精度的最坏情况下的边界。这一方法的缺点是它忽略了浮点表示中任何可能的抵消或效率</p>
<p>（2）最坏情况的经验程序：计算每一种假设的最坏情况并报道其所需精度。这种情况下就可以保证有充足的精度位去计算（a）每一个结果的权重；（b）最大可能结果的权重 + 一个有着最高小数精度位的权重。</p>
<p>因为尾数需要的最大尾数由最大可能权重和与表示任何单个权重所需的最高小数精度所决定</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 算法一：确定最小精度</span></span><br><span class="line"><span class="comment"># 输入：𝑢𝑚𝑖𝑛：最小效用值, 𝑢𝑚𝑎𝑥：最大效用值,𝑜𝑚𝑎𝑥：最大结果个数, 𝜂：隐私参数</span></span><br><span class="line"><span class="comment"># 输出：p：一个足够的精度，它不超过最小精度大小的两倍且可以成功运行base-2的指数机制</span></span><br><span class="line">procedure ComputePrecision(𝑢𝑚𝑖𝑛, 𝑢𝑚𝑎𝑥, 𝑜𝑚𝑎𝑥, 𝜂)</span><br><span class="line">	<span class="comment"># 初始化为1</span></span><br><span class="line">	𝑝 ← <span class="number">1</span></span><br><span class="line">    <span class="comment"># 如果检测精度失败则p加倍，并再次进行检测</span></span><br><span class="line">	<span class="keyword">while</span> CheckPrecision(𝑢𝑚𝑖𝑛, 𝑢𝑚𝑎𝑥, 𝑜𝑚𝑎𝑥, 𝜂, 𝑝) fails do</span><br><span class="line">		𝑝 ← <span class="number">2</span>𝑝</span><br><span class="line">	<span class="keyword">return</span> 𝑝</span><br><span class="line"><span class="comment"># 一旦程序中存在不精确计算就会返回failure</span></span><br><span class="line">function CheckPrecision(𝑢𝑚𝑖𝑛, 𝑢𝑚𝑎𝑥, 𝑜𝑚𝑎𝑥, 𝑏𝑎𝑠𝑒, 𝑝)</span><br><span class="line">	<span class="type">Set</span> the precision to 𝑝</span><br><span class="line">	<span class="keyword">return</span> failure on inexact arithmetic <span class="keyword">for</span>:</span><br><span class="line">	𝑚𝑎𝑥𝑠𝑢𝑚 ←𝑖∈[𝑜𝑚𝑎𝑥] <span class="number">2</span>^(−𝜂𝑢𝑚𝑖𝑛)</span><br><span class="line">	<span class="keyword">for</span> 𝑢∈[𝑢𝑚𝑖𝑛, 𝑢𝑚𝑎𝑥] do</span><br><span class="line">		𝑐𝑜𝑚𝑏𝑖𝑛𝑒𝑑𝑠𝑢𝑚 ← <span class="number">2</span>^(−𝜂𝑢) + ⌈𝑚𝑎𝑥𝑠𝑢𝑚⌉</span><br></pre></td></tr></table></figure>

<p><code>非整数效用值情形下隐私参数的选择</code></p>
<p>这种情况下采用的解决方法是：采用随即舍入，即向上或向下四舍五入到最接近的整数，其概率与整数的接近程度成正比。</p>
<p>基本策略：表明随机舍入不会因为不精确的实现而带来隐私损失</p>
<p>随机舍入指数机制会先分配一个整数代理效用值，然后再用这个值当作效用值进行之后的运算。</p>
<p>引理：具有任意精度随机舍入功能的指数机制是满足差分隐私的，这一论点来源于考虑最坏的舍入选择集，并认为隐私损失并不比这种情况更糟。</p>
<p>虽然随机舍入不会因为低精度的实现带来隐私损失，但是这一机制在多大程度上接近于原始的非整数效用方法还不是很明显。</p>
<p>命题3.6指出随即舍入不会很大程度地改变概率</p>
<h5 id="3-3不用除法进行归一化采样"><a href="#3-3不用除法进行归一化采样" class="headerlink" title="3.3不用除法进行归一化采样"></a>3.3不用除法进行归一化采样</h5><p>除法的问题在于：即使被除数和除数都可以用很小的二进制位精确表示，但是它们的商却不能被简单地表示。为此，提出了两种不采用除法的归一化方法</p>
<p><code>第一种方法</code></p>
<p>该方法源自观察：从[0, 𝑡)中均匀随机取样等同于从归一化分布中随机取样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 算法二：不使用除法进行权重归一化采样</span></span><br><span class="line"><span class="comment"># 输入：W：一个权重集合</span></span><br><span class="line"><span class="comment"># 输出：i：根据权重选出的采样下标</span></span><br><span class="line">procedure NormalizedSample(𝑊)</span><br><span class="line">	<span class="comment"># 计算总权重</span></span><br><span class="line">	𝑡 ← ∑𝑤∈𝑊 𝑤</span><br><span class="line">	𝑠 ← GetRandomValue(𝑝, 𝑡)</span><br><span class="line">    <span class="comment"># 计算累积权重</span></span><br><span class="line">	<span class="keyword">for</span> 𝑖 ∈ &#123;<span class="number">1</span>,...,|𝑊|&#125; do</span><br><span class="line">		𝑐𝑖 ← ∑𝑖,𝑗=<span class="number">1</span> 𝑤𝑗</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>&#123;𝑖|𝑐𝑖 &gt; 𝑠&#125;</span><br><span class="line"><span class="comment"># 输入：p:精度位数，t：范围上限</span></span><br><span class="line"><span class="comment"># 输出：一个从[0, 𝑡)中均匀随机采样取出的数</span></span><br><span class="line">function GetRandomValue(𝑝, 𝑡)</span><br><span class="line">	<span class="comment"># argmax：取最大值函数，求出g</span></span><br><span class="line">	𝑔 ← arg <span class="built_in">max</span> 𝑔&#123;<span class="number">2</span>^𝑔 ≤ 𝑡&#125;</span><br><span class="line">    <span class="comment"># 初始化s</span></span><br><span class="line">	Initialize 𝑠 ← ∞</span><br><span class="line">    <span class="comment"># 如果s不在[0, 𝑡)内则继续循环</span></span><br><span class="line">	<span class="keyword">while</span> 𝑠 ≥ 𝑡 do</span><br><span class="line">		<span class="keyword">for</span> 𝑖 ∈ &#123;<span class="number">1</span>,...,𝑝&#125; do</span><br><span class="line">        	<span class="comment"># 简单均匀随机取样</span></span><br><span class="line">			𝑟𝑖 ∼ Unif(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		𝑠 ←∑𝑝,𝑖=<span class="number">0</span> 𝑟𝑖*<span class="number">2</span>^(𝑔−𝑖)</span><br><span class="line">	<span class="keyword">return</span> 𝑠</span><br></pre></td></tr></table></figure>

<p><code>第二种方法</code></p>
<p>在范围[0, 𝑡)中通过在每一步丢弃一半的剩余范围执行随机的二分查找，当只剩余一个有效元素时停止。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 算法三：权重归一化采样算法</span></span><br><span class="line"><span class="comment"># 输入：W：一个权重集合</span></span><br><span class="line"><span class="comment"># 输出：i：根据权重选出的采样下标</span></span><br><span class="line">procedure NormalizedSample(𝑊)</span><br><span class="line">	<span class="comment"># 计算总权重</span></span><br><span class="line">	𝑡 ←∑𝑤∈𝑊 𝑤</span><br><span class="line">    <span class="comment"># 计算累积权重</span></span><br><span class="line">	<span class="keyword">for</span> 𝑖 ∈ &#123;<span class="number">1</span>,...,|𝑊|&#125; do</span><br><span class="line">		𝑐𝑖 ←∑𝑖,𝑗=<span class="number">1</span> 𝑤𝑗</span><br><span class="line">	𝑘 ← arg <span class="built_in">min</span>𝑘&#123;<span class="number">2</span>^𝑘 ≥ 𝑡 &#125; ⊲ The smallest power of two ≥ 𝑡.</span><br><span class="line">	<span class="keyword">if</span> <span class="number">2</span>^𝑘 &gt; 𝑡 then</span><br><span class="line">		𝑊 ← 𝑊 ∪ &#123;⊥&#125; ⊲ Add element ⊥ <span class="keyword">with</span> weight <span class="number">2</span>^𝑘 − 𝑡.</span><br><span class="line">		𝑐|𝑊| ← <span class="number">2</span>^𝑘 − 𝑡 ⊲ Total weight <span class="keyword">is</span> now <span class="number">2</span>^𝑘.</span><br><span class="line">	𝑠 ← <span class="number">0</span></span><br><span class="line">	𝑗 ← 𝑘 − <span class="number">1</span></span><br><span class="line">	𝑅 ← [|𝑊|] ⊲ the remaining elements</span><br><span class="line">	<span class="keyword">while</span> |𝑅| &gt; <span class="number">1</span> do</span><br><span class="line">		𝑟𝑗 ∼ Unif(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		𝑠 ← 𝑠 + 𝑟𝑗*<span class="number">2</span>^𝑗</span><br><span class="line">		<span class="keyword">for</span> 𝑖 ∈ 𝑅 do</span><br><span class="line">			<span class="keyword">if</span> 𝑐𝑖 ≤ 𝑠 then ⊲ 𝑠 cannot be <span class="keyword">in</span> [𝑐𝑖−<span class="number">1</span>, 𝑐𝑖), even <span class="keyword">if</span> <span class="built_in">all</span> draws are <span class="number">0.</span></span><br><span class="line">				𝑅 ← 𝑅\&#123;𝑖&#125;</span><br><span class="line">			<span class="keyword">if</span> 𝑖 &gt; <span class="number">0</span> <span class="keyword">and</span> 𝑐𝑖−<span class="number">1</span> ≥ 𝑠 + <span class="number">2</span>𝑗 then ⊲ 𝑠 cannot be <span class="keyword">in</span>[𝑐𝑖−<span class="number">1</span>, 𝑐𝑖), even <span class="keyword">if</span> maximum value added.</span><br><span class="line">				𝑅 ← 𝑅\&#123;𝑖&#125;</span><br><span class="line">		𝑗 ← 𝑗 − <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> |𝑅| = <span class="number">1</span> <span class="keyword">and</span> ⊥ ∈ 𝑅 then ⊲ Restart <span class="keyword">if</span> dummy value.</span><br><span class="line">			𝑠 ← <span class="number">0</span></span><br><span class="line">			𝑗 ← 𝑘 − <span class="number">1</span></span><br><span class="line">			𝑅 ← [|𝑊|]</span><br><span class="line"><span class="keyword">return</span> 𝑙</span><br></pre></td></tr></table></figure>

<p>引理3.7证明算法二和算法三等同于指数机制采样，且程序有很大概率最多使用O(p)的随机位数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 算法四：用最小的拒绝次数进行GETRANDOMVALUE操作</span></span><br><span class="line"><span class="comment"># 输入：p:精度位数，t：范围上限</span></span><br><span class="line"><span class="comment"># 输出：一个从[0, 𝑡)中均匀随机采样取出的数</span></span><br><span class="line">function GetRandomValue(𝑝, 𝑡)</span><br><span class="line">	𝑔 ← ⌊log2(𝑡)⌋</span><br><span class="line">	Initialize 𝑠 ← ∞, s∗ ← ∞, c ← <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> 𝑠 ≥ 𝑡 <span class="keyword">and</span> c &lt; k do ⊲ Reject 𝑠 <span class="keyword">if</span> it falls outside [<span class="number">0</span>, 𝑡) <span class="keyword">or</span> fewer than 𝑘 iterations.</span><br><span class="line">		<span class="keyword">for</span> 𝑖 ∈ &#123;<span class="number">1</span>, . . . , 𝑝&#125; do</span><br><span class="line">			𝑟𝑖 ∼ Unif(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		𝑠 ← ∑𝑝,𝑖=<span class="number">1</span>𝑟𝑖<span class="number">2</span>^(𝑔−𝑖)</span><br><span class="line">		<span class="keyword">if</span> 𝑠∗ = ∞ <span class="keyword">and</span> 𝑠 &lt; 𝑡 then</span><br><span class="line">			𝑠∗ ← 𝑠 ⊲ update 𝑠∗<span class="keyword">if</span> 𝑠 <span class="keyword">is</span> <span class="keyword">in</span> <span class="built_in">range</span>.</span><br><span class="line">		𝑐 ← 𝑐 + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> 𝑠∗</span><br></pre></td></tr></table></figure>

<h4 id="4-实现"><a href="#4-实现" class="headerlink" title="4.实现"></a>4.实现</h4><p><code>精确计算</code></p>
<p>采用GNU多重精度算法(GMP)和GNU MPFR库来实现高精度整数和浮点运算，通过python和rust语言访问这些库。这些库也提供了在运行时确定在给定系统上可实现的最大精度，避免由于超过任何系统特定的阈值而引发的错误的产生，且使得代码更容易进行审查。</p>
<p>MPFR提供了一组有用的标识符来指示操作不精确，结果溢出，下溢等问题</p>
<p><code>分离数据独立和数据依赖的逻辑</code></p>
<p><code>确定隐私参数</code></p>
<p><code>随机性来源</code></p>
<p><code>逻辑</code></p>
<p>实现的逻辑基本与朴素的指数机制相同，但是包括了效用函数的随机舍入，效用值夹紧，以及精确计算的额外监测</p>
<p><code>特定语言细节</code></p>
<p>python和rust语言实现上的区别</p>
<h5 id="4-1性能和应用"><a href="#4-1性能和应用" class="headerlink" title="4.1性能和应用"></a>4.1性能和应用</h5><p>所有的测试在拥有2核2GB内存的Linux虚拟机上，总体来说，Rust性能远远高于python，但是，由于基准测试的差异，呈现的实践不具有严格的可比性。</p>
<p><code>结果空间大小</code></p>
<p>选择了一个结果集𝑂 &#x3D; [𝑛]，且效用函数𝑢(𝑜) &#x3D; 𝑜。随着n的增大， 效用值范围和结果空间大小都增加。该测试证明：特别是在Rust语言中，即使是在低端配置情况下，当n&#x3D;75k时也能在大约10s内完成。</p>
<p>Note：base-2指数机制效率没有原始的指数机制效率高</p>
<p><code>精度确定方法</code></p>
<p>通过改变结果空间大小来展示经验精度确定的计算开销与精度降低之间的相对权衡导致的性能差异。该测试表明：随着n的增加，PythonEmp的性能远好于PythonTher的性能，即性能的改善效果要由于开销成本的增加；相反，RustEmp的性能却不如RustTher的性能</p>
<p><code>效用值范围</code></p>
<p>结果空间集固定为O&#x3D;1000，测试效用值范围增加时会怎样影响性能。设置𝑂 &#x3D; {0} ∪ {𝑖 +𝑛|𝑖 ∈ [𝑘]} 且𝑢(𝑜) &#x3D; 𝑜. 增长曲线是线性的，因为随着n的增加，成本增加的唯一原因是计算过程带来了更多的时间开销。</p>
<p><code>拉普拉斯</code></p>
<p>从拉普拉斯机制中采样的标准方法是使用逆变换采样，即在[0,1]中采样出一个均匀值U，然后求解CDF(t)&#x3D;U（CDF代表拉普拉斯分布的累积密度函数：对概率密度函数从−∞ 到t进行积分）。通过标准的ln函数实现该机制存在危险，但是通过[6]中提出的方法可以解决。</p>
<p>然后，拉普拉斯机制也可以通过将效用函数设置为𝑢(𝑑, 𝑜) &#x3D; |𝑓 (𝑑) −𝑜|进行实现。该测试表明：Python的性能由于PythonNaive，</p>
]]></content>
      <categories>
        <category>差分隐私（英文文献）</category>
      </categories>
      <tags>
        <tag>差分隐私</tag>
        <tag>Base-2指数机制</tag>
      </tags>
  </entry>
</search>
