<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Answering Multi-Dimensional Range Queries under Local Differential Privacy</title>
    <url>/post/c1df81ba.html</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>在<code>LDP</code>的保证下回答多维范围查询主要会遇到以下三个关键技术挑战：</p>
<p>（1）捕获属性之间的关联；</p>
<p>（2）处理维度多的范围查询；</p>
<p>（3）处理取值范围大的属性；</p>
<p>为了解决以上三个挑战，该文献首先提出了<code>TDG</code>算法（只采用二维网格）。然而这种算法丢失了单个属性的分布信息，因此为了解决该问题，进一步提出了<code>HDG</code>算法（一维网格与二维网格相结合），且大量的实验表明<code>HDG</code>算法的性能较于现有的算法有了较大的提升。</p>
<span id="more"></span>

<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><p><code>多维范围查询</code>：获取同时满足多个属性的限制条件的用户频率；</p>
<p>现有的解决范围查询的算法大部分受限于对单个属性的一维查询，并且不能很好地拓展到处理高维范围查询。该文献首先提出了<code>TDG</code>算法，其主要思想为将所有可能出现的属性对构成的二维域划分为可以回答所有二维查询的二维网格，然后根据这些相关的二维查询去回答更高维度的范围查询。然后提出了一个升级版的方法<code>HDG</code>算法，其主要思想为组合混合维度（一维网格和二维网格）的信息去进行更好的估计。在这两个算法中，用户都被分成组，每个组向一个网格报告其信息。在满足<code>LDP</code>的前提下将每个网格的频率都收集完后，融合中心使用技术实现网格的非负性和一致性，并且最终采用这些网格去回答范围查询。</p>
<p>总的来说，该文献的贡献如下：</p>
<p>（1）提出了<code>TDG</code>算法和<code>HDG</code>算法用于在<code>LDP</code>环境下回答多维范围查询，并且提供了基于不同来源的误差分析去选择网格粒度的基本准则；</p>
<p>（2）开展了大量的实验通过比较不同的算法去评估算法的性能，实验结果表明<code>HDG</code>算法比现有的算法高出一个数量级。</p>
<h2 id="2-初步——用户划分原则"><a href="#2-初步——用户划分原则" class="headerlink" title="2.初步——用户划分原则"></a>2.初步——用户划分原则</h2><p>用户分组在现有的<code>LDP</code>算法很常见。也就是说，当需要多个信息时，首先需要将所有用户进行分组，然后再从每个用户组中收集信息来获得最佳结果。</p>
<h1 id="3-多维范围查询和基线算法"><a href="#3-多维范围查询和基线算法" class="headerlink" title="3.多维范围查询和基线算法"></a>3.多维范围查询和基线算法</h1><h2 id="3-1多维范围查询"><a href="#3-1多维范围查询" class="headerlink" title="3.1多维范围查询"></a>3.1多维范围查询</h2><p>假设有<b>d</b>个有序属性<b>{a<sub>1</sub>, a<sub>2</sub>, … , a<sub>d</sub>}</b>，不失一般性，假设每个属性有相同的取值范围<b>[c] &#x3D; {1, 2, … , c}</b>，其中<b>c</b>是<b>2</b>的指数幂。用户总数量用<b>n</b>表示，第<b>i</b>个用户的隐私值是一个<b>d</b>维向量<b>vi &#x3D; &lt;v<sup>1</sup><sub>i</sub>, v<sup>2</sup><sub>i</sub>, … , v<sup>d</sup><sub>i</sub>, &gt;</b>。正式地，一个<b>λ</b>维范围查询<b>q</b>定义如下图所示：</p>
<img data-src="/post/c1df81ba/1.png" class title="λ维查询">

<p>定义<b>A<sub>q</sub></b>代表范围查询<b>q</b>所涉及到的所有属性，那么<b>q</b>的真实结果如下图所示：</p>
<img data-src="/post/c1df81ba/2.png" class title="范围查询真实结果">

<h2 id="3-2基线算法"><a href="#3-2基线算法" class="headerlink" title="3.2基线算法"></a>3.2基线算法</h2><h3 id="3-2-1边缘列联表发布算法"><a href="#3-2-1边缘列联表发布算法" class="headerlink" title="3.2.1边缘列联表发布算法"></a>3.2.1边缘列联表发布算法</h3><h4 id="3-2-1-1全列联表法（Full-Contingency-Table-Method，FC）"><a href="#3-2-1-1全列联表法（Full-Contingency-Table-Method，FC）" class="headerlink" title="3.2.1.1全列联表法（Full Contingency Table Method，FC）"></a>3.2.1.1全列联表法（Full Contingency Table Method，FC）</h4><p><code>算法思想</code>：根据所有用户在通过<code>LDP</code>扰动后上传的数据构建一个全列联表<b>F</b>，然后再通过<b>F</b>构建所有的边缘列联表；</p>
<p><code>算法缺点</code>：时间复杂度和空间复杂度都随着属性数量<b>d</b>的增加而指数级增加，当<b>d</b>很大时，实际的时空开销是不可接受的。一般来说，假设<b>Var<sub>0</sub></b>表示全列联表中每个单元的方差，那么计算<code>k-路边缘列联表</code>的方差如下图所示：</p>
<img data-src="/post/c1df81ba/3.png" class title="k-路边缘列联表的方差">

<h4 id="3-2-1-2全边缘列联表法（All-Marginal-Method，AM）"><a href="#3-2-1-2全边缘列联表法（All-Marginal-Method，AM）" class="headerlink" title="3.2.1.2全边缘列联表法（All Marginal Method，AM）"></a>3.2.1.2全边缘列联表法（All Marginal Method，AM）</h4><p><code>算法思想</code>：因为<code>FC</code>算法构建的<code>k-路边缘列联表</code>的方差与属性数量<b>d</b>呈指数级增长，因此考虑使用融合中心直接构建所有的<code>k-路边缘列联表</code>；</p>
<p><code>实现途径</code>：第一种途径是用户将其隐私预算分成<b>C<sup>k</sup><sub>d</sub></b>份，然后上传<b>C<sup>k</sup><sub>d</sub></b>次数据，即每次上传一个<code>k-路边缘列联表</code>；第二种途径是将所有用户划分成<b>C<sup>k</sup><sub>d</sub></b>个不同的用户组，每个用户只需上传一个<code>k-路边缘列联表</code>（一般来说，<code>LDP</code>场景下划分用户比划分隐私预算能获得更好的精度，因为划分隐私意味着每个<code>k-路边缘列联表</code>的隐私预算更小，那么就会被注入更大的噪声）。其中，因为将用户划分为<b>C<sup>k</sup><sub>d</sub></b>个组会给构建<code>k-路边缘列联表</code>带来<b>C<sup>k</sup><sub>d</sub></b>倍的影响，所以第二种算法的方差为：</p>
<img data-src="/post/c1df81ba/4.png" class title="k-路边缘列联表的方差">

<p><code>算法不足</code>：当<b>k</b>很大时，<code>AM</code>算法的精度会受到很大的影响；该算法的另外一个局限性在于<b>k</b>需要事先指定，且当融合中心完成所有<code>k-路边缘列联表</code>的构建时，无法再获取<code>t-路边缘列联表</code>（<b>t&gt;k</b>）。</p>
<h4 id="3-2-1-3CALM"><a href="#3-2-1-3CALM" class="headerlink" title="3.2.1.3CALM"></a>3.2.1.3CALM</h4><p><code>算法思想</code>：收集低纬度的边缘列联表并据此构建一个高维列联表；</p>
<p><code>算法评价</code>：CALM算法捕获了必要的属性之间的联系且解决了多维范围查询问题，但是没能处理取值范围大的属性。因为当属性的取值范围很大时，会在查询结果中引入大量的噪声。</p>
<h3 id="3-2-2HIO"><a href="#3-2-2HIO" class="headerlink" title="3.2.2HIO"></a>3.2.2HIO</h3><p><code>算法不足</code>：HIO算法捕获了所有属性之间的联系，但是其他两个问题没有解决。因为HIO算法需要将用户分成<b>(h+1)<sup>d</sup></b>组，其中<b>h&#x3D;log<sub>b</sub>c</b>，而当属性数量<b>d</b>和属性取值范围<b>c</b>很大时，每个用户组的用户数量会很少，这样就会引入大量的噪声并进一步导致更大的误差。</p>
<h3 id="3-2-2LHIO（待续）"><a href="#3-2-2LHIO（待续）" class="headerlink" title="3.2.2LHIO（待续）"></a>3.2.2LHIO（待续）</h3><h3 id="3-2-3MSW（待续）"><a href="#3-2-3MSW（待续）" class="headerlink" title="3.2.3MSW（待续）"></a>3.2.3MSW（待续）</h3><h1 id="4-网格方法"><a href="#4-网格方法" class="headerlink" title="4.网格方法"></a>4.网格方法</h1><h2 id="4-1概述"><a href="#4-1概述" class="headerlink" title="4.1概述"></a>4.1概述</h2><p>为了同时解决前文提到的三个挑战，该文献首先提出了二维网格算法<code>TDG</code>，其主要思想为将所有属性对的二维取值范围划分成可以回答所有二维范围查询的二维网格，并结合相关的二维网格去回答高维的范围查询；但是由于只采用了二维网格，当采用<code>TDG</code>算法去进行一维范围查询时就需要借助均匀分布假设，而这就会引入大量的误差，为了解决这一问题，进一步提出了混合维度网格算法<code>HDG</code>，其在二维网格的基础上进一步引入了一维网格，然后结合一维网格和二维网格一起去回答范围查询。</p>
<p><code>TDG</code>和<code>HDG</code>算法由来：一般来说，如果为了捕获属性之间的关联，那么当维度过大时范围查询将难以解决；如果只关注单个属性，那么就无法捕获属性之间的关联。受到<code>CALM</code>算法的启发，<code>TDG</code>和<code>HDG</code>算法都采用二维网格去权衡以上两点。</p>
<p><code>TDG</code>和<code>HDG</code>算法均由以下三步组成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.构建网格</span><br><span class="line">TDG算法：</span><br><span class="line">首先，融合中心根据d个属性得到m = (d,2)个属性对，并将所有用户随机分成m个用户组，每个用户组对应一个属性对；然后，对于每个属性对，融合中心通过将二维域[c]x[c]划分成同样粒度大小的二维单元构建一个二维网格；最后，为了获得每个二维网格中的二维单元中的加噪之后的频率值，融合中心指示对应二维网格中的用户组中的用户使用OLH算法报告其隐私数据所在的二维单元；</span><br><span class="line">HDG算法：</span><br><span class="line">除了构建上述二维网格之外，融合中心还要为d个属性分别构建一个一维网格。因此在HDG算法中，d + (d,2)个，并且用户被划分为同样数量的用户组，且每个用户组对应一个网格（ps：一维网格和二维网格的粒度大小可能不同）；</span><br><span class="line">2.去除负值和不一致性</span><br><span class="line">因为使用了OLH算法保证差分隐私，因此二维单元加噪之后的频率值可能为负值，这就违背了先验知识的非负性；而且，因为一个属性和多个网格相关，因此不同网格中注入在该属性上的噪声频率可能不同，从而导致网格之间的不一致。因此需要在这个阶段去除负值和不一致这两个问题；</span><br><span class="line">3.回答范围查询</span><br><span class="line">TDG算法：</span><br><span class="line">对于一个二维查询Q，融合中心首先找出与Q相关的二维网格G，然后再检查G里的每个二维单元：如果二维单元完全被包含在Q中，那么融合中心就将其加噪后的频率加到查询结果f(Q)中；如果二维单元部分被包含在Q中，那么融合中心就会采用均匀分布假设估计二维单元和查询Q中共同的二维值的频率值总和，并将其添加到f(Q)中；</span><br><span class="line">HDG算法：</span><br><span class="line">对于一个二维查询Q，融合中心首先找出与Q相关的二维网格G，然后再检查G里的每个二维单元：如果二维单元完全被包含在Q中，那么融合中心就将其加噪后的频率加到查询结果f(Q)中；如果二维单元部分被包含在Q中，那么融合中心先确定二维单元和查询Q中共同的二维值，然后再将响应矩阵中对应元素的总和添加到f(Q)中。</span><br></pre></td></tr></table></figure>

<h2 id="4-2网格后处理"><a href="#4-2网格后处理" class="headerlink" title="4.2网格后处理"></a>4.2网格后处理</h2><h3 id="4-2-1非负性"><a href="#4-2-1非负性" class="headerlink" title="4.2.1非负性"></a>4.2.1非负性</h3><p>这一步采用<code>Norm-Sub</code>方法，其可以使得所有估计值非负，并且所有估计值的总和为<b>1</b>；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Norm-Sub：</span><br><span class="line">1.所有负估计值转换为0；</span><br><span class="line">2.计算所有正估计值的总和与1之间的总差值；</span><br><span class="line">3.通过将总差值除以正估计值个数获得平均差；</span><br><span class="line">4.通过减去平均差更新每个正估计值；</span><br><span class="line">5.重复以上步骤直到所有的估计值都非负。</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2一致性"><a href="#4-2-2一致性" class="headerlink" title="4.2.2一致性"></a>4.2.2一致性</h3><p>对于某个属性<b>a</b>，其总共与<b>d</b>个网格相关（<b>1</b>一个一维网格和<b>d-1</b>个二维网格），假设这些网格为<b>{G<sub>1</sub>, G<sub>2</sub>, … , G<sub>d</sub>}</b>，对于整数<b>j ∈ [1, g<sub>2</sub>]</b>，定义<b>P<sub>G<sub>i</sub></sub>(a, j)</b>为第<b>G<sub>i</sub></b>个网格中第<b>j</b>个单元的频率总和。为了实现<b>P<sub>G<sub>i</sub></sub>(a, j)</b>的一致性，需要如下图所示计算加权平均，其中<b>θ<sub>i</sub></b>为<b>P<sub>G<sub>i</sub></sub>(a, j)</b>的权重：</p>
<img data-src="/post/c1df81ba/11.png" class title="加权平均计算">

<p>依据其他文献，得知当<b>θ<sub>i</sub></b>进行如下设置时，可以得到最优加权平均为：</p>
<img data-src="/post/c1df81ba/12.png" class title="权重设置">

<img data-src="/post/c1df81ba/13.png" class title="最优加权平均">

<p>得到<b>P(a, j)</b>之后需要让每个<b>P<sub>G<sub>i</sub></sub>(a, j)</b>都相等，可以通过以下方式实现： 对于<b>S<sub>i</sub></b>中的每个单元，通过下图所示的添加变化量来更新其频率：</p>
<img data-src="/post/c1df81ba/14.png" class title="变化量">

<blockquote>
<p>ps：可以发现一致性步骤可能会引入负值，反之亦然。因此在整个网格后处理过程中，需要多次交换执行这两个步骤，而因为响应矩阵的每个元素必须非负，因此以非负性步骤结束网格的后处理。尽管最后一步可能会再次引入不一致性，但其往往很小。</p>
</blockquote>
<h2 id="4-3建立响应矩阵"><a href="#4-3建立响应矩阵" class="headerlink" title="4.3建立响应矩阵"></a>4.3建立响应矩阵</h2><p>每一个属性对都对应一个大小为<b>[c]x[c]</b>的响应矩阵，其中矩阵中的每个元素代表对应二维值在该二维域中的频率，响应矩阵的建立如下图所示：</p>
<img data-src="/post/c1df81ba/5.png" class title="建立响应矩阵">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">算法描述：</span><br><span class="line">1.将响应矩阵中的[c]x[c]个元素都初始化为1/c^2；</span><br><span class="line">2.对于每个二维单元S，将S中所有二维值的频率求和得到总频率Y；</span><br><span class="line">3.将单个二维值的频率除以Y得到该二维值的频率；</span><br><span class="line">4.重复2-3步直到收敛（收敛的标准为：每次更新过程之后响应矩阵中所有元素的改变总和低于一个给定的阈值）</span><br></pre></td></tr></table></figure>

<h2 id="4-4λ维范围查询"><a href="#4-4λ维范围查询" class="headerlink" title="4.4λ维范围查询"></a>4.4λ维范围查询</h2><p>为了估计λ维范围查询Q的结果，融合中心首先将Q分成（λ，2）个相关的二维查询，并获取所有二位查询的结果，最后融合中心使用这些二位查询结果去估计f(Q)，下图给出了λ维范围查询结果的估计算法：</p>
<img data-src="/post/c1df81ba/6.png" class title="λ维范围查询">

<h2 id="4-5隐私和效用分析"><a href="#4-5隐私和效用分析" class="headerlink" title="4.5隐私和效用分析"></a>4.5隐私和效用分析</h2><h3 id="4-5-1隐私保证"><a href="#4-5-1隐私保证" class="headerlink" title="4.5.1隐私保证"></a>4.5.1隐私保证</h3><p>TDG和HDG算法都满足LDP，因为用户通过OLH算法上传其数据至融合中心，且没有泄露其他信息。</p>
<h3 id="4-5-2误差分析"><a href="#4-5-2误差分析" class="headerlink" title="4.5.2误差分析"></a>4.5.2误差分析</h3><p><code>噪声和采样误差</code>：</p>
<p>一方面，为了满足LDP隐私保证，需要对每一个单元注入一定的噪声，这便引入了<code>噪声误差</code>。而因为对每个单元的噪声注入都是唯一的，因此这些噪声就相当于一些独立随机变量，那么这些噪声总和的方差等于所有噪声方差的总和，所以单元分的越精细，注入噪声的方差就会越大；另一方面，需要使用某个用户组中单元的频率去代表整个人口的频率，但可能当前选择的用户组与全局的的分布不同，这就会引入<code>采样误差</code>；</p>
<p><code>不均匀误差</code>：</p>
<p><code>不均匀误差</code>是由与查询矩形相交但不完全包含在其中的单元引起的。 对于这些单元一般需要假设数据点是均匀分布的，而这会在数据点不均匀分布时导致非均匀误差。 通常，任何相交单元格中此误差的大小取决于该单元格中数据点的数量，并受其限制。 因此，分区粒度越细，<code>不均匀误差</code>越小。 计算精确的非均匀性误差需要真实数据分布的可用性，这在我们的设置中并非如此。 因此选择计算近似的<code>不均匀误差</code>；</p>
<p><code>估计误差</code>：</p>
<p>由于<code>估计误差</code>取决于数据集，因此没有用于估计它的公式。 一般来说，二维范围查询的更准确的答案可以导致更小的<code>估计误差</code>。 但是，其大小取决于数据集的特点会引入不确定性，这意味着在少数情况下可能会出现相反的结果。</p>
<h2 id="4-6选择粒度"><a href="#4-6选择粒度" class="headerlink" title="4.6选择粒度"></a>4.6选择粒度</h2><p><code>基本准则</code>：</p>
<p>为了最小化误差，一维网格的粒度如下图所示：</p>
<img data-src="/post/c1df81ba/7.png" class title="一维网格粒度">

<p>二维网格的粒度如下图所示：</p>
<img data-src="/post/c1df81ba/8.png" class title="二维网格粒度">

<p>其中<b>n<sub>i</sub></b>是<b>i</b>维网格的用户数，<b>m<sub>i</sub></b>是<b>i</b>维网格的用户组数，<b>α<sub>1</sub></b>、<b>α<sub>2</sub></b>为依赖数据集的常数。</p>
<p><code>对于g1的分析</code>：</p>
<p>对于一维查询，当粒度为<b>g<sub>1</sub></b>时，平均情况下大概有<b>g<sub>1</sub>&#x2F;2</b>个单元被包含在查询中，那么<code>噪声和采样误差</code>为：</p>
<img data-src="/post/c1df81ba/9.png" class title="噪声和采样误差">

<p><code>不均匀误差</code>与与查询区间两侧相交的单元中值的频率之和成正比。 假设对于某个常数<b>α<sub>1</sub></b>，<code>不均匀误差</code>为<b>α<sub>1</sub>&#x2F;g<sub>1</sub></b>，那么它的平方误差为<b>(α<sub>1</sub>&#x2F;g<sub>1</sub>)<sup>2</sup></b>；</p>
<p>综上，为了最小化误差总和和，因此<b>g<sub>1</sub></b>根据如下表达式进行设置：</p>
<img data-src="/post/c1df81ba/7.png" class title="一维网格粒度">

<p><code>对于g2的分析</code>：</p>
<p>从一维拓展到二维，当二维粒度为<b>g<sub>2</sub></b>时，平均情况下大概有<b>(g<sub>2</sub>&#x2F;2)<sup>2</sup></b>个单元被包含在查询中，那么<code>噪声和采样误差</code>为：</p>
<img data-src="/post/c1df81ba/10.png" class title="噪声和采样误差">

<p><code>不均匀误差</code>与落在查询矩形四个边缘上的单元中值的频率之和成正比。查询矩形的边包含<b>4 x (g<sub>2</sub>&#x2F;2) &#x3D; 2g<sub>2</sub></b>个单元； 并且这些单元中包含的值的预期频率总和为<b>2g<sub>2</sub> x (1&#x2F;(g<sub>2</sub> x g<sub>2</sub>)) &#x3D; 2 &#x2F; g<sub>2</sub></b>。 与一维网格设置类似，假设平均情况下<code>不均匀误差</code>是其中的一部分。 那么对于某个常数 <b>α<sub>2</sub></b>，不均匀的平方误差为<b>(2α<sub>2</sub> &#x2F; g<sub>2</sub>)<sup>2</sup></b>；</p>
<p>综上，为了最小化误差总和和，因此<b>g<sub>2</sub></b>根据如下表达式进行设置：</p>
<img data-src="/post/c1df81ba/8.png" class title="一维网格粒度">
]]></content>
      <categories>
        <category>差分隐私（英文文献）</category>
      </categories>
      <tags>
        <tag>差分隐私</tag>
        <tag>Range Query</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo和Github搭建博客</title>
    <url>/post/bf8017ed.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本人的博客采用<code>Hexo+Github</code>的方式完成，采用这两者相结合的方式的原因在于：一方面，虽然<code>Hexo</code>是一个静态博客框架，但是本人觉得个人博客只在于记录一些学习过程中的心得和学习笔记，所以静态博客框架完全可以满足这种需求；另一方面，<code>Github</code>提供了<code>Github Pages</code>这种免费的静态站点托管服务，这对于我这种学生党来说无疑是一种福音。</p>
<span id="more"></span>

<h1 id="Hexo版本信息"><a href="#Hexo版本信息" class="headerlink" title="Hexo版本信息"></a>Hexo版本信息</h1><p>鉴于Hexo框架更新迭代较快，当版本不同时很多配置文件都不相同，因此建议选择对应版本的教程进行阅读。以下是本人的Hexo版本具体信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hp@LAPTOP-RB9QDBHV MINGW64 /f/My-Blog</span><br><span class="line">$ hexo v</span><br><span class="line">NexT version 8.12.2</span><br><span class="line">Documentation: https://theme-next.js.org</span><br><span class="line">========================================</span><br><span class="line">hexo: 6.2.0</span><br><span class="line">hexo-cli: 4.3.0</span><br><span class="line">os: win32 10.0.19043</span><br><span class="line">node: 14.15.1</span><br><span class="line">v8: 8.4.371.19-node.17</span><br><span class="line">uv: 1.40.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.9</span><br><span class="line">ares: 1.16.1</span><br><span class="line">modules: 83</span><br><span class="line">nghttp2: 1.41.0</span><br><span class="line">napi: 7</span><br><span class="line">llhttp: 2.1.3</span><br><span class="line">openssl: 1.1.1g</span><br><span class="line">cldr: 37.0</span><br><span class="line">icu: 67.1</span><br><span class="line">tz: 2020a</span><br><span class="line">unicode: 13.0</span><br></pre></td></tr></table></figure>

<h1 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h1><p>Hexo博客的搭建已于Node.js，博客搭建过程中需要使用Git进行博客版本控制，因此首先需要安装这两个工具：</p>
<blockquote>
<p>（1）Node.js: <code>http://nodejs.cn/download/</code></p>
<p>（2）Git: <code>https://git-scm.com/downloads</code></p>
</blockquote>
<p>安装完成之后，<code>Win+R</code>输入<code>cmd</code>打开命令行窗口，输入<code>node -v</code>, <code>npm -v</code>, <code>git --version</code>检查是否安装成功（ps：<code>Node.js</code>中安装了<code>npm</code>命令安装模块，因此不需要额外安装）。若<code>cmd</code>窗口如下图所示，说明安装成功，如下图所示：</p>
<img data-src="/post/bf8017ed/1.png" class title="安装检查">

<h1 id="2-创建Github仓库"><a href="#2-创建Github仓库" class="headerlink" title="2.创建Github仓库"></a>2.创建Github仓库</h1><p>首先需要使用<code>Git</code>命令行连接到自己的<code>Github</code>账号（这个网上教程很多，这里不再赘述）；因为需要使用<code>Github Pages</code>服务，所以需要在<code>Github</code>中先创建一个仓库，：<code>Repository name</code>中填入<code>Github用户名.github.io</code>，并勾选<code>Add a README file</code>，如下图所示：</p>
<img data-src="/post/bf8017ed/2.png" class title="创建Github仓库">

<h1 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h1><p>首先需要在本地新建一个文件夹用于存放博客程序所有文件，例如<code>My-Blog</code>。然后进入<code>My-Blog</code>文件夹，右键选择<code>Git Bash Here</code>打开<code>Git</code>命令窗口，然后依次输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli		# 安装Hexo博客程序</span><br><span class="line">hexo init					# 初始化</span><br><span class="line">npm install					# 安装组件</span><br><span class="line">hexo g						# 生成页面</span><br><span class="line">hexo s						# 启动预览</span><br></pre></td></tr></table></figure>

<p>访问<code>http://localhost:4000</code>，若出现<code>Hexo</code>默认界面，则说明安装成功。</p>
<h1 id="4-部署Hexo至Github"><a href="#4-部署Hexo至Github" class="headerlink" title="4.部署Hexo至Github"></a>4.部署Hexo至Github</h1><p>首先安装<code>hexo-deployer-git</code>插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后修改站点配置文件（<code>My-Blog/_config.yml</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:用户名/用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>然后在<code>Git</code>命令窗口中输入<code>hexo d</code>命令将博客上传部署到<code>Github Pages</code>中。</p>
<p>注意到我们这里是将<code>Hexo</code>博客上传到了<code>master</code>分支，因此需要在中将默认分支改为<code>master</code>，如下图所示：</p>
<img data-src="/post/bf8017ed/3.png" class title="更改默认分支">

<p>至此所有安装部署操作均已完成，这时访问<code>https://用户名.github.io</code>就可以看到我们自己的网站了！</p>
<h1 id="5-创建并发布文章"><a href="#5-创建并发布文章" class="headerlink" title="5.创建并发布文章"></a>5.创建并发布文章</h1><p>首先打开本地博客程序根目录（<code>My-Blog</code>），右键选择<code>Git Bash Here</code>，输入以下命令创建文章：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;文章名称&quot;</span><br></pre></td></tr></table></figure>

<p>此时会发现在<code>My-Blog/source/_posts</code>文件夹中出现了“文章名称.md”文件，然后便可在本地打开该文件进行文章的内容编辑（建议使用<code>Typora</code>）。</p>
<p>文章写完之后需要执行<code>hexo g</code>命令渲染成前端界面，然后执行<code>hexo d</code>命令部署到Github上，这样就完成了一篇文章的发布：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean	# 清除缓存文件（可以不执行该命令）</span><br><span class="line">hexo g		# 生成页面</span><br><span class="line">hexo d		# 部署页面</span><br></pre></td></tr></table></figure>

<h1 id="6-站点配置文件"><a href="#6-站点配置文件" class="headerlink" title="6.站点配置文件"></a>6.站点配置文件</h1><p>站点配置文件位于<code>My-Blog/_config.yml</code>该文件内容的介绍如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: 					# 博客标题</span><br><span class="line">subtitle: 				# 博客子标题</span><br><span class="line">description: 			# 博客描述</span><br><span class="line">keywords: 				# 关键词，用于SEO优化</span><br><span class="line">author: 				# 作者名称</span><br><span class="line">language: zh-CN			# 语言	</span><br><span class="line">timezone: 				# 时区</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="line">url: https://用户名.github.io/</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: :title.md 	# 新文章命名方式</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link:</span><br><span class="line">  enable: true # Open external links in new tab</span><br><span class="line">  field: site # Apply to the whole site</span><br><span class="line">  exclude: &#x27;&#x27;</span><br><span class="line"></span><br><span class="line"># Home page setting</span><br><span class="line"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><span class="line"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class="line"># order_by: Posts order. (Order by date descending by default)</span><br><span class="line">index_generator:</span><br><span class="line">  path: &#x27;&#x27;</span><br><span class="line">  per_page: 10		# 每页文章数量</span><br><span class="line">  order_by: -date	# 文章排序方法</span><br><span class="line"></span><br><span class="line"># 时间格式</span><br><span class="line"># Date / Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line">## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;</span><br><span class="line">updated_option: &#x27;mtime&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next			# 主题设置（选择My-Blog/themes文件夹下对应的主题目录名称）</span><br><span class="line"></span><br><span class="line"># 部署配置</span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:用户名/用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<h1 id="7-主题配置文件（Next）"><a href="#7-主题配置文件（Next）" class="headerlink" title="7.主题配置文件（Next）"></a>7.主题配置文件（Next）</h1><p>主题配置文件位于<code>My-Blog/themes/主题名称/_config.yml</code>鉴于<code>Next</code>主题集成了丰富的插件，且网上对于其优化的解决办法也相当充足，因此采用了<code>Next</code>主题，其主题配置文件如下所示（这里只展示部分配置，具体的美化配置请见后面的<code>Next美化配置</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 自定义文件（设置这些文件时，需要在My-Blog/source文件下新建对应的文件，并将对应的注释符号去除）</span><br><span class="line"># Define custom file paths.</span><br><span class="line"># Create your custom files in site directory `source/_data` and uncomment needed files below.</span><br><span class="line">custom_file_path:</span><br><span class="line">  #head: source/_data/head.njk</span><br><span class="line">  #header: source/_data/header.njk</span><br><span class="line">  #sidebar: source/_data/sidebar.njk</span><br><span class="line">  #postMeta: source/_data/post-meta.njk</span><br><span class="line">  #postBodyEnd: source/_data/post-body-end.njk</span><br><span class="line">  #footer: source/_data/footer.njk</span><br><span class="line">  #footer: source/_data/footer.njk</span><br><span class="line">  #bodyEnd: source/_data/body-end.njk</span><br><span class="line">  #variable: source/_data/variables.styl</span><br><span class="line">  #mixin: source/_data/mixins.styl</span><br><span class="line">  #style: source/_data/styles.styl</span><br><span class="line"></span><br><span class="line"># 主题格式设置（设置哪一种格式，就将哪一种格式前面的注释符合去除）</span><br><span class="line"># Schemes</span><br><span class="line">scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br><span class="line"></span><br><span class="line"># 网站图标设置（自定义网站图标时，需要将图标放置在My-Blog/themes/next/source/images文件夹下，并在下面设置相应的图标名称）</span><br><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16-next.png</span><br><span class="line">  medium: /images/favicon-32x32-next.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br><span class="line">  #android_manifest: /manifest.json</span><br><span class="line"></span><br><span class="line"># 菜单设置（在需要的标签前面去除注释符号即可展示在主页中）</span><br><span class="line">menu:</span><br><span class="line">  #home: / || fa fa-home</span><br><span class="line">  #about: /about/ || fa fa-user</span><br><span class="line">  #tags: /tags/ || fa fa-tags</span><br><span class="line">  #categories: /categories/ || fa fa-th</span><br><span class="line">  #archives: /archives/ || fa fa-archive</span><br><span class="line">  #schedule: /schedule/ || fa fa-calendar</span><br><span class="line">  #sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: /404/ || fa fa-heartbeat</span><br><span class="line"></span><br><span class="line"># 菜单图标设置</span><br><span class="line"># Enable / Disable menu icons / item badges.</span><br><span class="line">menu_settings:</span><br><span class="line">  icons: true</span><br><span class="line">  badges: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 侧边栏设置</span><br><span class="line">sidebar:</span><br><span class="line">  # 位置</span><br><span class="line">  # Sidebar Position.</span><br><span class="line">  position: left</span><br><span class="line">  #position: right</span><br><span class="line"></span><br><span class="line">  # 宽度</span><br><span class="line">  width: 300</span><br><span class="line"></span><br><span class="line">  # 展示方式</span><br><span class="line">  display: post</span><br><span class="line"></span><br><span class="line">  # Sidebar padding in pixels.</span><br><span class="line">  padding: 18</span><br><span class="line">  # Sidebar offset from top menubar in pixels (only for Pisces | Gemini).</span><br><span class="line">  offset: 12</span><br><span class="line"></span><br><span class="line"># 侧边栏头像设置</span><br><span class="line">avatar:</span><br><span class="line">  # 自定义头像需要在My-Blog/themes/next/source/images文件夹下放置头像，并对下面的url进行相应的修改</span><br><span class="line">  url: /images/avatar.png</span><br><span class="line">  # 是否以圆形进行展示（圆形/方形）</span><br><span class="line">  rounded: true</span><br><span class="line">  # 是否旋转</span><br><span class="line">  rotated: false</span><br><span class="line"></span><br><span class="line"># 社交链接设置（需要展示哪些社交链接只需去除其前面的注释）</span><br><span class="line">social:</span><br><span class="line">  #GitHub: https://github.com/yourname || fab fa-github</span><br><span class="line">  #E-Mail: mailto:yourname@gmail.com || fa fa-envelope</span><br><span class="line">  #Weibo: https://weibo.com/yourname || fab fa-weibo</span><br><span class="line">  #Google: https://plus.google.com/yourname || fab fa-google</span><br><span class="line">  #Twitter: https://twitter.com/yourname || fab fa-twitter</span><br><span class="line">  #FB Page: https://www.facebook.com/yourname || fab fa-facebook</span><br><span class="line">  #StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow</span><br><span class="line">  #YouTube: https://youtube.com/yourname || fab fa-youtube</span><br><span class="line">  #Instagram: https://instagram.com/yourname || fab fa-instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || fab fa-skype</span><br><span class="line">  </span><br><span class="line"># 社交链接图标设置</span><br><span class="line">social_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  icons_only: false		# 是否只展示图标</span><br><span class="line">  transition: false		# 是否需要过渡效果</span><br><span class="line"></span><br><span class="line"># 页脚设置</span><br><span class="line">footer:</span><br><span class="line">  # 展示网站创立的年份</span><br><span class="line">  since: 2022</span><br><span class="line"></span><br><span class="line">  # 网站创立时间和版权信息之间的图标</span><br><span class="line">  icon:</span><br><span class="line">    # Icon name in Font Awesome. See: https://fontawesome.com/icons</span><br><span class="line">    name: fa fa-user</span><br><span class="line">    # If you want to animate the icon, set it to true.</span><br><span class="line">    animated: false</span><br><span class="line">    # Change the color of icon, using Hex Code.</span><br><span class="line">    color: &quot;#999999&quot;</span><br><span class="line"></span><br><span class="line">  # If not defined, `author` from Hexo `_config.yml` will be used.</span><br><span class="line">  copyright:</span><br><span class="line"></span><br><span class="line">  # 是否需要在页脚展示&quot;Powered by Hexo &amp; NexT&quot;</span><br><span class="line">  powered: false</span><br><span class="line"></span><br><span class="line"># 是否需要&quot;回到顶部&quot;功能</span><br><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # Back to top in sidebar.</span><br><span class="line">  sidebar: false</span><br><span class="line">  # Scroll percent label in b2t button.</span><br><span class="line">  scrollpercent: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 是否需要点击图片放大功能</span><br><span class="line">fancybox: true</span><br></pre></td></tr></table></figure>

<h1 id="8-Next美化配置"><a href="#8-Next美化配置" class="headerlink" title="8.Next美化配置"></a>8.Next美化配置</h1><h2 id="8-1摘要文字长度"><a href="#8-1摘要文字长度" class="headerlink" title="8.1摘要文字长度"></a>8.1摘要文字长度</h2><p>摘要文字长度建议使用<code>&lt;!--more--&gt;</code>进行手动设置，很多插件虽然也能直接设置长度，但个人觉得插件实现的效果不是很好，具体实现方法如下：</p>
<p>首先在主题配置文件<code>My-Blog/themes/主题名称/_config.yml</code>中进行如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">excerpt_description: true</span><br><span class="line"></span><br><span class="line">read_more_btn: true</span><br></pre></td></tr></table></figure>

<p>然后在需要发布的文章的md文件中添加<code>&lt;!--more--&gt;</code>，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 文章标题</span><br><span class="line">tags: Hexo</span><br><span class="line">categories: 搭建博客</span><br><span class="line"></span><br><span class="line">摘要文字</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">其他内容</span><br></pre></td></tr></table></figure>

<p>这样设置之后，在文章摘要页面就只能看到”摘要文字”，而看不到”其他内容”。</p>
<h2 id="8-2文章末尾添加统一结束语"><a href="#8-2文章末尾添加统一结束语" class="headerlink" title="8.2文章末尾添加统一结束语"></a>8.2文章末尾添加统一结束语</h2><p>在<code>Hexo</code>博客程序根目录下的<code>source</code>文件夹中新建<code>_data/post-body-end.njk</code>文件，并进行如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px; padding-top: 10px;&quot;&gt;--------------------------------------- &lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt; 本文结束，感谢您的阅读 &lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt; ---------------------------------------  &lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>之后，需要在主题配置文件中查找<code>custom_file_path</code>，并去除<code>postBodyEnd: source/_data/post-body-end.njk</code>前面的注释符号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  #head: source/_data/head.njk</span><br><span class="line">  #header: source/_data/header.njk</span><br><span class="line">  #sidebar: source/_data/sidebar.njk</span><br><span class="line">  #postMeta: source/_data/post-meta.njk</span><br><span class="line">  postBodyEnd: source/_data/post-body-end.njk</span><br><span class="line">  #footer: source/_data/footer.njk</span><br><span class="line">  #footer: source/_data/footer.njk</span><br><span class="line">  #bodyEnd: source/_data/body-end.njk</span><br><span class="line">  #variable: source/_data/variables.styl</span><br><span class="line">  #mixin: source/_data/mixins.styl</span><br><span class="line">  #style: source/_data/styles.styl</span><br></pre></td></tr></table></figure>

<h2 id="8-3代码块"><a href="#8-3代码块" class="headerlink" title="8.3代码块"></a>8.3代码块</h2><p>进入主题配置文件<code>My-Blog/themes/主题名称/_config.yml</code>并进行如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  # 代码块主题</span><br><span class="line">  theme:</span><br><span class="line">    light: default</span><br><span class="line">    dark: stackoverflow-dark</span><br><span class="line">  prism:</span><br><span class="line">    light: prism</span><br><span class="line">    dark: prism-dark</span><br><span class="line">  # 是否支持一键复制</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    style: mac</span><br></pre></td></tr></table></figure>

<h2 id="8-4今日诗词"><a href="#8-4今日诗词" class="headerlink" title="8.4今日诗词"></a>8.4今日诗词</h2><p>在<code>Hexo</code>博客程序根目录下的<code>source</code>文件夹中新建<code>_data/post-body-end.njk</code>文件，并进行如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;//sdk.jinrishici.com/v2/browser/jinrishici.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  jinrishici.load((result) =&gt; &#123;</span><br><span class="line">    let jrsc = document.getElementById(&#x27;jrsc&#x27;);</span><br><span class="line">    const data = result.data;</span><br><span class="line">    let author = data.origin.author;</span><br><span class="line">    let title = &#x27;《&#x27; + data.origin.title + &#x27;》&#x27;;</span><br><span class="line">    let content = data.content.substr(0, data.content.length - 1);</span><br><span class="line">    let dynasty = data.origin.dynasty.substr(0, data.origin.dynasty.length - 1);</span><br><span class="line">    jrsc.innerText = content + &#x27; &#x27; + &#x27;[&#x27; + dynasty + &#x27;]&#x27; + author + title;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;div style=&quot;text-align: center&quot;&gt;&lt;span id=&quot;jrsc&quot; &gt;正在加载今日诗词....&lt;/span&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>之后，需要在主题配置文件中查找<code>custom_file_path</code>，并去除<code>postBodyEnd: source/_data/post-body-end.njk</code>前面的注释符号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  #head: source/_data/head.njk</span><br><span class="line">  #header: source/_data/header.njk</span><br><span class="line">  #sidebar: source/_data/sidebar.njk</span><br><span class="line">  #postMeta: source/_data/post-meta.njk</span><br><span class="line">  postBodyEnd: source/_data/post-body-end.njk</span><br><span class="line">  #footer: source/_data/footer.njk</span><br><span class="line">  #footer: source/_data/footer.njk</span><br><span class="line">  #bodyEnd: source/_data/body-end.njk</span><br><span class="line">  #variable: source/_data/variables.styl</span><br><span class="line">  #mixin: source/_data/mixins.styl</span><br><span class="line">  #style: source/_data/styles.styl</span><br></pre></td></tr></table></figure>

<h2 id="8-5奖赏"><a href="#8-5奖赏" class="headerlink" title="8.5奖赏"></a>8.5奖赏</h2><p>进入主题配置文件<code>My-Blog/themes/主题名称/_config.yml</code>并进行如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reward_settings:</span><br><span class="line">  # If true, a donate button will be displayed in every article by default.</span><br><span class="line">  enable: true				# 是否开启奖赏功能</span><br><span class="line">  animation: true			# 动画</span><br><span class="line">  #comment: Buy me a coffee</span><br><span class="line"></span><br><span class="line"># 去粗话需要的支付方式前面的注释符号，并在My-Blog/themes/主题名称/source/images文件夹下放入对应的图片</span><br><span class="line">reward:	</span><br><span class="line">  #wechatpay: /images/wechatpay.png</span><br><span class="line">  #alipay: /images/alipay.png</span><br><span class="line">  #paypal: /images/paypal.png</span><br><span class="line">  #bitcoin: /images/bitcoin.png</span><br></pre></td></tr></table></figure>

<h2 id="8-6页面加载效果"><a href="#8-6页面加载效果" class="headerlink" title="8.6页面加载效果"></a>8.6页面加载效果</h2><p>进入主题配置文件<code>My-Blog/themes/主题名称/_config.yml</code>并进行如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pace:</span><br><span class="line">  enable: true</span><br><span class="line">  # 所有可选颜色:</span><br><span class="line">  # black | blue | green | orange | pink | purple | red | silver | white | yellow</span><br><span class="line">  color: black</span><br><span class="line">  # 所有可选主题:</span><br><span class="line">  # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span><br><span class="line">  # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span><br><span class="line">  theme: loading-bar</span><br></pre></td></tr></table></figure>

<h1 id="9-结束语"><a href="#9-结束语" class="headerlink" title="9.结束语"></a>9.结束语</h1><p>基于Hexo+Github搭建博客就讲到这，对于Next主题的美化其实还有很多内容，鉴于网上教程过多，这里就只列出一部分。总体来说，能够完成个人博客的搭建，我个人的所有需求基本满足，日后我会继续在这里更新我阅读的每一篇文献，希望有兴趣的朋友可以多多关注！</p>
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>差分隐私综述</title>
    <url>/post/46d864ff.html</url>
    <content><![CDATA[<h3 id="1-差分隐私的两个目标"><a href="#1-差分隐私的两个目标" class="headerlink" title="1.差分隐私的两个目标"></a>1.差分隐私的两个目标</h3><p>（1）隐私保护中, 如何在分享数据时定义隐私</p>
<p>（2）如何在保证可用性的数据发布时, 提供隐私保护的问题</p>
<span id="more"></span>

<h3 id="2-差分隐私背景："><a href="#2-差分隐私背景：" class="headerlink" title="2.差分隐私背景："></a>2.差分隐私背景：</h3><p>差分隐私对于隐私的定义不依赖于攻击者的背景知识</p>
<h3 id="3-隐私信息的全生命周期模型（9个部分）"><a href="#3-隐私信息的全生命周期模型（9个部分）" class="headerlink" title="3.隐私信息的全生命周期模型（9个部分）"></a>3.隐私信息的全生命周期模型（9个部分）</h3><p>隐私信息产生, 隐私感知, 隐私保护, 隐私发布, 隐私信息存储, 隐私交换, 隐私分析, 隐私销毁, 隐私接收者</p>
<h3 id="4-隐私保护的方式（主要有三种）"><a href="#4-隐私保护的方式（主要有三种）" class="headerlink" title="4.隐私保护的方式（主要有三种）"></a>4.隐私保护的方式（主要有三种）</h3><p>数据失真、加密、访问控制</p>
<h3 id="5-准标识符"><a href="#5-准标识符" class="headerlink" title="5.准标识符"></a>5.准标识符</h3><p>可以和外部表链接来识别个体的最小属性集</p>
<h3 id="6-准标识符假设"><a href="#6-准标识符假设" class="headerlink" title="6.准标识符假设"></a>6.准标识符假设</h3><p>数据持有者可以识别出其所持有数据表中可能出现在外部数据中的属性，因此其可以准确的识别出准标识符集合（实际上这个假设不可能成立）</p>
<h3 id="7-K匿名算法"><a href="#7-K匿名算法" class="headerlink" title="7.K匿名算法"></a>7.K匿名算法</h3><p>通过概括和隐匿技术，发布精度较低的技术，使得每条记录至少与数据表中其他k-1条记录具有完全相同的准标识符属性值，从而减少链接攻击所导致的隐私泄露。</p>
<p>缺点：无法抵抗同质攻击，背景知识攻击和补充数据攻击等</p>
<h3 id="8-等价类"><a href="#8-等价类" class="headerlink" title="8.等价类"></a>8.等价类</h3><p>拥有相同准标识符的所有记录</p>
<h3 id="9-l-diversity（l-多样性）"><a href="#9-l-diversity（l-多样性）" class="headerlink" title="9.l-diversity（l-多样性）"></a>9.l-diversity（l-多样性）</h3><p>一个等价类里的敏感属性至少有l个良表示的取值</p>
<p>缺点：因为在一个真实的数据集中, 属性值很有可能是偏斜的或者语义相近的, 而 l-多样性只保证了多样性，没有认识到在属性值上语义相近的情况</p>
<h3 id="10-可区分良表示"><a href="#10-可区分良表示" class="headerlink" title="10.可区分良表示"></a>10.可区分良表示</h3><p>同一等价类中的敏感属性至少有l个可区分的取值</p>
<h3 id="11-顺序合成性质、平行合成性质"><a href="#11-顺序合成性质、平行合成性质" class="headerlink" title="11.顺序合成性质、平行合成性质"></a>11.顺序合成性质、平行合成性质</h3><p>一个算法序列同时作用在一个数据集上时；多个算法序列分别作用在一个数据集上多个不同子集上时</p>
<h3 id="12-控制隐私预算的目的"><a href="#12-控制隐私预算的目的" class="headerlink" title="12.控制隐私预算的目的"></a>12.控制隐私预算的目的</h3><p>如果在一个较低隐私预算参数的情况下, 攻击者对一个数据集进行了多次查询, 那么根据顺序合成性质, 攻击者实际上获得的隐私预算就相当于获得了多次查询的隐私预算的和, 而这就破坏了原本设定的隐私预算，所以需要控制隐私预算的上限。</p>
<h3 id="13-变换不变性"><a href="#13-变换不变性" class="headerlink" title="13.变换不变性"></a>13.变换不变性</h3><p>满足差分隐私的算法经过后处理之后仍然满足差分隐私</p>
<h3 id="14-中凸性"><a href="#14-中凸性" class="headerlink" title="14.中凸性"></a>14.中凸性</h3><p>如果有2个不同的差分隐私算法, 都提供了足够的不确定性来保护隐私, 那么可以通过选择任意的算法来应用到数据上实现对数据的隐私保护, 只要选择的算法和数据是独立的</p>
<h3 id="15-曼哈顿距离"><a href="#15-曼哈顿距离" class="headerlink" title="15.曼哈顿距离"></a>15.曼哈顿距离</h3><p>两个点在标准坐标系上的绝对轴距综合。这里的曼哈顿距离就相当于对称差值，其度量了修改一个元组时查询结果的最大变化</p>
<h3 id="16-全局敏感度（与数据集无关，只由查询函数本身决定）"><a href="#16-全局敏感度（与数据集无关，只由查询函数本身决定）" class="headerlink" title="16.全局敏感度（与数据集无关，只由查询函数本身决定）"></a>16.全局敏感度（与数据集无关，只由查询函数本身决定）</h3><p>控制噪声的重要参数。定义为查询函数f作用于任意两个相邻数据集得到的查询结果的曼哈顿距离</p>
<h3 id="17-局部敏感度（由查询函数和给定的数据集共同决定）"><a href="#17-局部敏感度（由查询函数和给定的数据集共同决定）" class="headerlink" title="17.局部敏感度（由查询函数和给定的数据集共同决定）"></a>17.局部敏感度（由查询函数和给定的数据集共同决定）</h3><p>定义为查询函数f作用于给定两个相邻数据集得到的查询结果的曼哈顿距离</p>
<p>缺陷：局部敏感度不满足差分隐私的要求，因为噪声大小本身可能会揭示数据库信息</p>
<h3 id="18-平滑上界、平滑敏感度（为了弥补局部敏感度的缺陷而提出）"><a href="#18-平滑上界、平滑敏感度（为了弥补局部敏感度的缺陷而提出）" class="headerlink" title="18.平滑上界、平滑敏感度（为了弥补局部敏感度的缺陷而提出）"></a>18.平滑上界、平滑敏感度（为了弥补局部敏感度的缺陷而提出）</h3><h3 id="19-拉普拉斯机制"><a href="#19-拉普拉斯机制" class="headerlink" title="19.拉普拉斯机制"></a>19.拉普拉斯机制</h3><p>在查询结果上加入一个满足拉普拉斯分布的噪声来实现差分隐私保护，所加入的拉普拉斯噪声的均值要求为 0，这样输出的才是无偏估计</p>
<h3 id="20-指数机制"><a href="#20-指数机制" class="headerlink" title="20.指数机制"></a>20.指数机制</h3><p>对于任意一个可用性函数q和一个差分隐私预算 , 随机算法 M 以正比于的概率输出一个o作为结果</p>
<img data-src="/post/46d864ff/1.png" class title="指数机制">

<h3 id="21-SSE、MSE、RMSE"><a href="#21-SSE、MSE、RMSE" class="headerlink" title="21.SSE、MSE、RMSE"></a>21.SSE、MSE、RMSE</h3><p>和方差、均方误差、均方根误差</p>
<h3 id="22-隐私预算表达式"><a href="#22-隐私预算表达式" class="headerlink" title="22.隐私预算表达式"></a>22.隐私预算表达式</h3><img data-src="/post/46d864ff/2.png" class title="隐私预算">

<h3 id="23-研究现状"><a href="#23-研究现状" class="headerlink" title="23.研究现状"></a>23.研究现状</h3><p>（1）差分隐私虽然现在已经被用于数据挖掘，推荐系统等领域，但是差分隐私对于挖掘数据保护后，还能对数据分析者提供多少可用信息目前还没有一个合理通用的度量方法</p>
<p>（2）差分隐私与机器学习的结合将是未来的一个研究热点</p>
<p>（3）在差分隐私和机器学习中，主要有以下问题需要解决</p>
<p>​			（a）因为传统机器学习方法不能满足差分隐私的需求，需要解决样本数据集中缺失数据的问题</p>
<p>​			（b）医疗数据集中, 很多体征数据只是暂时的，而且对于数据的扰动很有可能使数据失去重要的信息, 因此需要有应对这种类型数据的差分隐私模型</p>
<p>​			（c）隐私是否能在不牺牲机器学习模型可用性的条件下实现</p>
<p>​			（d）在正则化的机器学习模型中, 差分隐私是否可以与正则化的想法兼容</p>
]]></content>
      <categories>
        <category>差分隐私（中文综述）</category>
      </categories>
      <tags>
        <tag>差分隐私</tag>
      </tags>
  </entry>
  <entry>
    <title>本地差分隐私保护综述</title>
    <url>/post/b16e3800.html</url>
    <content><![CDATA[<h1 id="1-众包模式"><a href="#1-众包模式" class="headerlink" title="1.众包模式"></a>1.众包模式</h1><p>一个公司或机构把过去由员工执行的工作任务，以自由自愿的形式外包给非特定的，而且通常是大型的大众网络的模式</p>
<h1 id="2-隐私保护的目标"><a href="#2-隐私保护的目标" class="headerlink" title="2.隐私保护的目标"></a>2.隐私保护的目标</h1><p>在数据收集阶段引入隐私保护机制来降低并控制隐私泄露的风险，平衡隐私保护与数据可用性之间的关系，解决和完善针对不牺牲用户个人隐私的大数据分析问题和机制</p>
<span id="more"></span>

<h1 id="3-传统隐私保护算法的缺陷"><a href="#3-传统隐私保护算法的缺陷" class="headerlink" title="3.传统隐私保护算法的缺陷"></a>3.传统隐私保护算法的缺陷</h1><p>（1）集中存储模型下，非可信数据管理者使用户无法直接控制个人隐私数据（<code>DP</code>也存在这一问题）</p>
<p>（2）由于背景知识无法明确界定，基于等价类的隐私保护模型被迫随着新攻击技术的出现而不断被动调整（3）无法提供严格且有效的数学理论来证明其隐私保护水平，无法定量分析隐私泄露风险</p>
<p>（4）值得重视的是，即使被严格处理的数据也可能泄露用户隐私</p>
<h1 id="4-本地差分隐私保护（LDP）的优势"><a href="#4-本地差分隐私保护（LDP）的优势" class="headerlink" title="4.本地差分隐私保护（LDP）的优势"></a>4.本地差分隐私保护（LDP）的优势</h1><p>本地差分隐私保护可以在不需要信任第三方数据管理者的情况下，直接在本地将隐私数据加噪来保护个人信息不被泄露，同时从宏观角度保证数据收集者可正确地推断出群体统计信息</p>
<h1 id="5-LDP应用场景"><a href="#5-LDP应用场景" class="headerlink" title="5.LDP应用场景"></a>5.LDP应用场景</h1><p>（1）集值型流式频繁项集挖掘的Heavy Hitters估计</p>
<p>（2）众包模式下字符串边缘频率估计和联合概率估计</p>
<p>（3）针对智能设备的机器学习</p>
<h1 id="6-布鲁姆过滤器（Bloom-Filter）"><a href="#6-布鲁姆过滤器（Bloom-Filter）" class="headerlink" title="6.布鲁姆过滤器（Bloom Filter）"></a>6.布鲁姆过滤器（Bloom Filter）</h1><p>（1）定义：由一个超长的二进制位数组和一系列的哈希函数组成。二进制位数组初始值全部为0，当给定一个待查询的元素时，这个元素会被一系列哈希函数计算映射出一系列的值，所有的值在位数组的偏移量处置为1</p>
<img data-src="/post/b16e3800/1.png" class title="布鲁姆过滤器">

<p>（2）判断元素是否在集合中的方法：元素经过一系列哈希函数计算后得到所有的偏移位置，若这些位置全都为1，则判断这个元素在这个集合中，若有一个不为1，则判断这个元素不在这个集合中</p>
<p>（3）优点：节省空间，采用位数组，2的32次方&#x3D;4294967296 可以看到42亿长度的位数组占用4294967296&#x2F;8&#x2F;1024&#x2F;1024&#x3D;512MB 只需占用512MB的内存空间</p>
<p>（4）缺点：有一定的误判，有可能把不在这个集合中的误判为在这个集合中，因为另一个元素经过哈希后各个位置也可能为1</p>
<h1 id="7-差分隐私分类"><a href="#7-差分隐私分类" class="headerlink" title="7.差分隐私分类"></a>7.差分隐私分类</h1><p>根据其应用场景及针对数据处理和收集方式的不同，主要存在两种数据分布模型：</p>
<p>（1）集中式模型（分为交互式和非交互式框架），又称为可信管理者模型（<code>Trusted Curator</code>）：服务器端直接存储未处理的原始用户隐私数据，并经过隐私处理等方式后统一对外发布</p>
<p>（2）本地模型（<code>Local Model</code>）：服务器端只能收到用户加噪的数据；用户在向数据收集者发送个人数据前，先在本地加入满足差分隐私的噪声扰动，最后数据收集者根据收集到的噪声数据，从统计学的角度近似估计出用户群体的统计特性，而不是针对具体用户个体进行统计特性推断</p>
<h1 id="8-中位数机制（目前没弄懂）"><a href="#8-中位数机制（目前没弄懂）" class="headerlink" title="8.中位数机制（目前没弄懂）"></a>8.中位数机制（目前没弄懂）</h1><h1 id="9-本地差分隐私保护主要思想"><a href="#9-本地差分隐私保护主要思想" class="headerlink" title="9.本地差分隐私保护主要思想"></a>9.本地差分隐私保护主要思想</h1><p>（1）不能收集或拥有任何个人的精确信息</p>
<p>（2）可以推断出用户群体的泛化统计信息</p>
<h1 id="10-DP与LDP的区别"><a href="#10-DP与LDP的区别" class="headerlink" title="10.DP与LDP的区别"></a>10.DP与LDP的区别</h1><p>两者最重要的区别在于加入噪声扰动的时机不同</p>
<img data-src="/post/b16e3800/2.png" class title="DP与LDP区别">

<h1 id="11-本地模型下的数据分析流程"><a href="#11-本地模型下的数据分析流程" class="headerlink" title="11.本地模型下的数据分析流程"></a>11.本地模型下的数据分析流程</h1><p>每个本地用户用随机器Q扰乱个人数据v得到Z，数据收集者将其汇总得到S，最后进行数据分析；</p>
<p>拉普拉斯机制经常被用于本地模型中，常用于对数值型结果的隐私保护</p>


<h1 id="12-随机响应RR（Randomized-Response）"><a href="#12-随机响应RR（Randomized-Response）" class="headerlink" title="12.随机响应RR（Randomized Response）"></a>12.随机响应RR（Randomized Response）</h1><p>（1）应用：保护敏感话题调查参与者隐私，目前主流的本地差分隐私保护都是基于RR</p>
<p>（2）具体应用场景：每个人不是属于组A就是组B，问题是在不能确定具体个人属于哪组的前提下，估计组A中人数的比例</p>
<p>（3）RR的解决方案：随机选取n个人，随机设备 (可以是抛硬币、摸球模型)以概率P指向A，以概率(1 一p)指向B。在每轮调查中，受访者只需回答设备指向(调查者未知)的组别是否与其真正的组别一致(Yes或No)，这样便可以得到组A人数的最大似然估计</p>
<p>（4）随机响应的效果：实现了ε-LDP，其中ε&#x3D;ln(p&#x2F;(1-p))</p>
<p>（5）存在问题：现有的基于RR技术的LDP机制在数据挖掘中具有一定的局限性，只适用于用户数据类型为数值型或范围型， 而数据收集者的数据挖掘任务局限于基本统计，如计数或求中位值等</p>
<p>（6）RR技术及其改进模型在收集群体层面的统计数据而不泄露个体数据方面具有优越性能，目前已成为新的研究热点</p>
<h1 id="13-随机响应RR举例"><a href="#13-随机响应RR举例" class="headerlink" title="13.随机响应RR举例"></a>13.随机响应RR举例</h1><p>（1）问题：假设有<code>n</code>个用户，其中艾滋病患者的比例为<code>π</code>，我们希望对<code>π</code>进行统计。于是对目标用户发起问卷调查：“你是否为艾滋病患者？”显然，如果直接获得用户的相应数据进行统计，一旦数据泄露，那么用户隐私随即泄露。因此，我们假设存在一枚非均匀的硬币，其正面向上的概率为<code>p</code>，反面向上的概率为<code>1-p</code>。抛出该硬币，若正面向上，则回答真实答案，反面向上，则回答相反的答案。</p>
<p>（2）推导过程：</p>
<ol>
<li><p>（step 1）</p>
<p>理论上，<code>Pr[Xi=“是”]=πp+(1-π)(1-p)</code>，<code>Pr[Xi=“否”]=(1-π)p+π(1-p)</code>。直觉上，当<code>n</code>足够大时，设回答“是”的人数为<code>n1</code>，回答“否”的人数为<code>n2</code>。<code>Pr[Xi=“是”]=n1/n</code>，<code>Pr[Xi=“否”]=n2/n</code>。求解下面的二次方程即可获得<code>π</code>的值</p>
<img data-src="/post/b16e3800/4.png" class title="二次方程">

<p>但是，<code>上述的结果并非真实比例的无偏估计</code>，我们用极大似然估计(<code>Max Likehood Estimation</code>)对统计结果进行校正</p>
</li>
<li><p>（step 2）</p>
<p>首先构建最大似然函数：</p>
<img data-src="/post/b16e3800/5.png" class title="最大似然函数">

<p>对数似然函数为：</p>
<img data-src="/post/b16e3800/6.png" class title="对数似然函数">

<p>令</p>
<img data-src="/post/b16e3800/7.png" class title="求解对数似然函数">

<p>求解可得<code>π</code>的极大似然估计：</p>
<img data-src="/post/b16e3800/8.png" class title="最大似然估计">

<p>由此可得患有<code>HIV</code>的总人数为：</p>
<img data-src="/post/b16e3800/9.png" class title="求总人数"></li>
</ol>
<h1 id="14-LDP研究方向"><a href="#14-LDP研究方向" class="headerlink" title="14.LDP研究方向"></a>14.LDP研究方向</h1><p>（1）基于随机应答与<code>Bloom Filter</code>的编解码方式研究（<code>RAPPOR</code>）</p>
<p>（2）针对流式频繁项集挖掘<code>Heavy Hitters</code>挖掘</p>
<p>（3）针对智能终端的收集与机器学习</p>
<h1 id="1RAPPOR算法（Google-Chrome）"><a href="#1RAPPOR算法（Google-Chrome）" class="headerlink" title="1RAPPOR算法（Google Chrome）"></a>1RAPPOR算法（Google Chrome）</h1><p><code>RAPPOR</code>应答被定义为比特位字符串，每一 位都是对应用户端特性报告的逻辑谓词随机应答， 用来收集用户群体的数值和序数值的统计，可以提供<code>ln(3)</code>的差分隐私保护（因为是基于随机响应技术，根据<code>13.随机响应RR</code>可求得隐私预算）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：用户数据X，参数k(串长度)，h(Hash个数)，概率参数f、p、q</span><br><span class="line">输出：数据报告s</span><br><span class="line">算法流程：</span><br><span class="line">(1)信号处理。用BloomFilter中的h个哈希函数将X编码成长度为k的01串B。 </span><br><span class="line">(2)永久随机响应(PRR)。利用随机应答技术对B进行扰动得到永久随机响应B&#x27;。 </span><br><span class="line">(3)即时随机响应(IRR)。利用随机应答技术对B&#x27;进行二次扰动得到即时随机响应s。 </span><br><span class="line">(4)报文。把收集的报告s发送到服务器</span><br></pre></td></tr></table></figure>

<blockquote>
<p>RAPPOR在解码过程中结合成熟的假设检验、最小二乘求解和LASSO回归实现针对字符串抽样群体频率的高可用解码框架</p>
</blockquote>
<p>存在问题：</p>
<p>（1）使用RAPPOR的数据收集者只能孤立地了解单一变量的分布。实际上，研究多个变量之间的关联更有意义</p>
<p>（2）数据收集者必须事先知道潜在字符串字典、安装软件的报告、名称、hash值，然而这些是不可能作为先验知识的</p>
]]></content>
      <categories>
        <category>差分隐私（中文综述）</category>
      </categories>
      <tags>
        <tag>差分隐私</tag>
      </tags>
  </entry>
  <entry>
    <title>AHEAD: Adaptive Hierarchical Decomposition for Range Query under Local Differential Privacy</title>
    <url>/post/8d2d0774.html</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>为了保护用户的隐私数据，人们使用本地差分隐私（<code>LDP</code>）提供支持隐私保护的范围查询，并支持进一步的统计分析。然而，现有的基于<code>LDP</code>的范围查询方法受限于其属性。而这种静态框架在低隐私预算场景下会带来过量的噪声。因此，提出了<code>AHEAD（Adaptive Hierarchical Decomposition）</code>方案，它可以自适应且动态地控制树的结构，进而注入的噪声可以得到较好地控制。</p>
<span id="more"></span>

<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><h2 id="1-1DP和LDP的执行流程"><a href="#1-1DP和LDP的执行流程" class="headerlink" title="1.1DP和LDP的执行流程"></a>1.1DP和LDP的执行流程</h2><p><code>DP</code>：一个可信的中心聚合器从用户端收集到敏感数据，然后再执行扰动分析，最后通过回答查询或者发布合成数据来提供数据服务；</p>
<p><code>LDP</code>：用户首先在本地对自己的隐私数据进行编码和扰动，然后再将处理过后的数据传输给聚合器。</p>
<h2 id="1-2LDP的研究"><a href="#1-2LDP的研究" class="headerlink" title="1.2LDP的研究"></a>1.2LDP的研究</h2><p><code>频率估计问题（Frequency Oracle）</code>（即获得整个域的频率分布）是<code>LDP</code>过去的主要研究内容，然而实际上人们可能对范围查询更加感兴趣。而且，根据范围查询结果，我们可以直接获得其他分布特征（如顺序统计量）；</p>
<p><code>顺序统计量</code>：在一个由<code>n</code>个元素组成的集合中，第<code>i</code>个顺序统计量即为该集合中第<code>i</code>小的元素。</p>
<h2 id="1-3范围查询"><a href="#1-3范围查询" class="headerlink" title="1.3范围查询"></a>1.3范围查询</h2><p>范围查询根据查询维度可以划分为低维度查询（维度小于等于2）和高维度查询（维度大于等于2）：</p>
<p><code>低维度查询</code>：王等人提出了基于完全B叉树结构分层分解整个域并且通过累积频率值来回答范围查询；Cormode等人提出在扰动的时候使用离散小波变换将用户的隐私值转化为一个哈尔变化系数向量并且执行其逆变换得到查询结果；</p>
<h3 id="1-3-1离散小波变换（待续）"><a href="#1-3-1离散小波变换（待续）" class="headerlink" title="1.3.1离散小波变换（待续）"></a>1.3.1离散小波变换（待续）</h3><h3 id="1-3-2哈尔小波变换（待续）"><a href="#1-3-2哈尔小波变换（待续）" class="headerlink" title="1.3.2哈尔小波变换（待续）"></a>1.3.2哈尔小波变换（待续）</h3><p><code>高维度查询</code>：杨等人提出从一二维网格组合信息，并且使用加权更新策略去估计高纬度的范围查询。</p>
<h2 id="1-4现有的方法存在的限制"><a href="#1-4现有的方法存在的限制" class="headerlink" title="1.4现有的方法存在的限制"></a>1.4现有的方法存在的限制</h2><p>大多数真实世界数据集中的数据域中存在<code>稀疏区域</code>（也就是某些区间的比重可能非常小），因此在网格或完全树中的值较小的结点可能被注入的噪声淹没；</p>
<p>现有的科技主要为具体维度的查询而设计（而实际数据集是经常变化的）（可以理解为都是<code>静态框架</code>），虽然每一种方法技术上不受查询维度的限制，但是在非目标维度的情况下有效性会降低，为了解决维度变化问题，聚合器需要组合为不同维度设计的算法，而这会限制这些算法的适用性和实用性。</p>
<h2 id="1-5文章的贡献"><a href="#1-5文章的贡献" class="headerlink" title="1.5文章的贡献"></a>1.5文章的贡献</h2><p>提出了一种在<code>LDP</code>下解决范围查询的动态算法<code>AHEAD</code>，它可以自适应地觉得域组合的粒度大小；</p>
<p>理论上推导了在满足严格的<code>LDP</code>保证下能实现高效用的参数设置；</p>
<p>通过大量实验证实了<code>AHEAD</code>算法的有效性。</p>
<h1 id="2-背景"><a href="#2-背景" class="headerlink" title="2.背景"></a>2.背景</h1><h2 id="2-1频率估计（Frequency-Oracle）"><a href="#2-1频率估计（Frequency-Oracle）" class="headerlink" title="2.1频率估计（Frequency Oracle）"></a>2.1频率估计（Frequency Oracle）</h2><p>频率估计是用来估计某个隐私属性的频率分布F，作为一般<code>LDP</code>任务（<code>边际释放</code>和<code>范围查询</code>）的基本构建块。大部分<code>FO</code>算法包括三部分：编码、扰动和聚合。</p>
<h2 id="2-2两种FO协议（GRR和OUE）"><a href="#2-2两种FO协议（GRR和OUE）" class="headerlink" title="2.2两种FO协议（GRR和OUE）"></a>2.2两种FO协议（GRR和OUE）</h2><h3 id="2-2-1广义随机响应（Generalized-Randomized-Response-GRR）"><a href="#2-2-1广义随机响应（Generalized-Randomized-Response-GRR）" class="headerlink" title="2.2.1广义随机响应（Generalized Randomized Response, GRR）"></a>2.2.1广义随机响应（Generalized Randomized Response, GRR）</h3><blockquote>
<p>Ps：随机响应算法的广义版本，目前我理解的是先对隐私数据进行扰动再进行编码</p>
</blockquote>
<p><code>编码</code>：对于用户<code>i</code>的隐私数据<code>Vi</code>，将其编码为<code>Xi</code>；</p>
<p><code>扰动</code>：用户<code>i</code>以根据以下式子选择<code>Vi</code>的值，并将扰动后的隐私值对应的编码<code>Xi&#39;</code>上传到服务器（其中<code>Vi&#39;</code>是从数据集<code>D</code>中随机选择）；</p>
<img data-src="/post/8d2d0774/1.png" class title="广义随机响应">

<p><code>聚合</code>：聚合器首先收集所有经过用户扰动之后的数据，然后计算每个数据<code>V</code>的频率<code>count[V]</code>，<code>count[V]</code>的一个无偏估计为：</p>
<img data-src="/post/8d2d0774/2.png" class title="&#96;count[V]&#96;的无偏估计">

<p><code>估计误差</code>：<code>GRR</code>的估计误差源自算法方差：</p>
<img data-src="/post/8d2d0774/3.png" class title="GRR算法方差">

<h3 id="2-2-2优化的一元编码（Optimized-Unary-Encoding-OUE）"><a href="#2-2-2优化的一元编码（Optimized-Unary-Encoding-OUE）" class="headerlink" title="2.2.2优化的一元编码（Optimized Unary Encoding, OUE）"></a>2.2.2优化的一元编码（Optimized Unary Encoding, OUE）</h3><blockquote>
<p>Ps：<code>RAPPOR</code>算法的优化版本</p>
</blockquote>
<p><code>编码</code>：对于用户<code>i</code>的隐私数据<code>Vi</code>，采用<code>独热编码</code>的方式将其编码为一个长为长度<code>|D|</code>的向量，其中<code>Vi</code>数据对应向量的第<code>i</code>个值为<code>1</code>，其余均为<code>0</code>；</p>
<h4 id="2-2-2-1One-Hot-Encoding（独热编码）"><a href="#2-2-2-1One-Hot-Encoding（独热编码）" class="headerlink" title="2.2.2.1One-Hot Encoding（独热编码）"></a>2.2.2.1One-Hot Encoding（独热编码）</h4><p><code>One-Hot编码</code>，又称为一位有效编码，即采用<code>N</code>个独立的寄存器对<code>N</code>个状态进行编码，对于每个状态，只有一个寄存器的值为<code>1</code>，其余寄存器的值都为<code>0</code></p>
<p><code>扰动</code>：对上一步得到的每个数据都采用<code>GRR</code>方法进行扰动，具体对每个数据的每一位来说，如果该位为<code>1（0）</code>，则以概率<code>p（q）</code>保持不变，以概率<code>1-p（1-q）</code>进行反转，然后用户将扰动后的编码<code>Xi&#39;</code>传输到服务器</p>
<p><code>聚合</code>：聚合器收集到所有经过用户扰动后的数据，然后对每一位为1的个数进行频率统计得到<code>count[V]</code>，<code>count[V]</code>的一个无偏估计为：</p>
<img data-src="/post/8d2d0774/2.png" class title="&#96;count[V]&#96;的无偏估计">

<p><code>估计误差</code>：算法方差为：</p>
<img data-src="/post/8d2d0774/4.png" class title="算法方差">

<blockquote>
<p>总结：可以看到，<code>GRR</code>和<code>OUE</code>算法都得到了频率值的无偏估计，而且，<code>OUE</code>算法的方差独立于数据集大小<code>|D|</code>。所以对于更小的<code>|D|</code>，<code>GRR</code>算法更好；而对于更大的<code>|D|</code>，<code>OUE</code>算法更好</p>
</blockquote>
<h1 id="3-现有的解决方案（针对范围查询问题）"><a href="#3-现有的解决方案（针对范围查询问题）" class="headerlink" title="3.现有的解决方案（针对范围查询问题）"></a>3.现有的解决方案（针对范围查询问题）</h1><h2 id="3-1Hierarchical-Interval-Optimized（HIO）"><a href="#3-1Hierarchical-Interval-Optimized（HIO）" class="headerlink" title="3.1Hierarchical-Interval Optimized（HIO）"></a>3.1Hierarchical-Interval Optimized（HIO）</h2><h3 id="3-1-1算法描述"><a href="#3-1-1算法描述" class="headerlink" title="3.1.1算法描述"></a>3.1.1算法描述</h3><p>基于<code>B</code>叉树，<code>HIO</code>算法将整个域分层分解为相互不相交的子集称为<code>区间</code>。根节点代表整个域，叶节点代表单个的值，其中相同层的结点代表相同粒度的<code>区间</code>。<code>HIO</code>算法通过<code>OUE</code>算法获得每一层结点的频率估计值，且通过使用最少的来自不同层的区间来回答范围查询。</p>
<blockquote>
<p>对于范围长度为<code>r</code>的一般查询，<code>HIO</code>算法最多需要2（B-1）log<sub>B</sub>|D|个区间进行回答</p>
</blockquote>
<h3 id="3-1-2算法不足"><a href="#3-1-2算法不足" class="headerlink" title="3.1.2算法不足"></a>3.1.2算法不足</h3><p>在所有区间的估计频率值中插入了相同级别的噪声，对于小区间的结点，扰动噪声可能会淹没真实的频率值，进而降低了整个算法的有效性；</p>
<p>在多维度场景中，树的层数随着维度的变化呈指数级增长；</p>
<p>在高维度场景中，查询误差因为小区间的结点数量过多，查询误差会不断增加。</p>
<h2 id="3-2Discrete-Haar-Wavelet-Transform（DHT）"><a href="#3-2Discrete-Haar-Wavelet-Transform（DHT）" class="headerlink" title="3.2Discrete Haar Wavelet Transform（DHT）"></a>3.2Discrete Haar Wavelet Transform（DHT）</h2><h3 id="3-2-1算法描述"><a href="#3-2-1算法描述" class="headerlink" title="3.2.1算法描述"></a>3.2.1算法描述</h3><p><code>DHT</code>算法对于整个域采用采用完全二叉树结构，并且把用户的隐私数据编码为一个<code>哈尔小波系数集合</code>。</p>
<blockquote>
<p>对于范围长度为<code>r</code>的查询，<code>DHT</code>算法比起直接采用<code>FO</code>算法能够在哈尔变换域中使用更少数量的估计值</p>
</blockquote>
<h3 id="3-2-2算法不足"><a href="#3-2-2算法不足" class="headerlink" title="3.2.2算法不足"></a>3.2.2算法不足</h3><p>与<code>HIO</code>算法相似，在所有区间的估计频率值中插入了相同级别的噪声，对于小区间的结点，扰动噪声可能会淹没真实的频率值，进而降低了整个算法的有效性；</p>
<p>主要针对一维场景设计，因此限制了其实际的应用场景。</p>
<h2 id="3-3Consistent-Adaptive-Local-Marginal（CALM）"><a href="#3-3Consistent-Adaptive-Local-Marginal（CALM）" class="headerlink" title="3.3Consistent Adaptive Local Marginal（CALM）"></a>3.3Consistent Adaptive Local Marginal（CALM）</h2><h3 id="3-3-1列联表（Contingency-table）"><a href="#3-3-1列联表（Contingency-table）" class="headerlink" title="3.3.1列联表（Contingency table）"></a>3.3.1列联表（Contingency table）</h3><p><code>列联表</code>：观测数据按两个或更多属性（定性变量）分类时所列出的频数表，是由两个以上的变量进行交叉分类的频数分布表，其分析的<code>基本问题</code>是判明所考察的个属性之间有无关联（即是否独立）。若所考虑的属性多于两个则称为<code>多维列联表</code>。如果考虑集合的全部属性，则称为<code>全列联表</code>；如果考虑集合的部分属性，则称为<code>边缘列联表</code>。若考虑集合的属性个数为k，则称为<code>k-路边缘列联表</code>。</p>
<blockquote>
<p>Ps：全列联表就是联合概率密度分布，边缘列联表就是边缘概率密度分布</p>
</blockquote>
<h3 id="3-3-2算法描述（有点复杂，待续）"><a href="#3-3-2算法描述（有点复杂，待续）" class="headerlink" title="3.3.2算法描述（有点复杂，待续）"></a>3.3.2算法描述（有点复杂，待续）</h3><p><code>CALM</code>算法是一种满足<code>LDP</code>定义的<code>边缘列联表发布（Marginal Release）</code>方案，它可以在隐私保护保证的背景下构建<code>m</code>个属性的列联表。该算法使用对重构的被包含在查询中的列联表进行求和来对范围查询进行回答。</p>
<h3 id="3-3-3算法不足"><a href="#3-3-3算法不足" class="headerlink" title="3.3.3算法不足"></a>3.3.3算法不足</h3><p>当数据集大小<code>|D|</code>很大时，<code>CALM算法</code>在回答一个查询时会加入大量的加噪列联表，而这很可能会给真实值注入大量的噪声。</p>
<h2 id="3-4Hybird-Dimensional-Grids（HDG）"><a href="#3-4Hybird-Dimensional-Grids（HDG）" class="headerlink" title="3.4Hybird-Dimensional Grids（HDG）"></a>3.4Hybird-Dimensional Grids（HDG）</h2><h3 id="3-4-1算法描述"><a href="#3-4-1算法描述" class="headerlink" title="3.4.1算法描述"></a>3.4.1算法描述</h3><p>仔细地将属性对的二维域都划分到粗的二维网格中，并且从相关的二维范围查询的答案中估计更高维度范围查询的结果。为了捕获用户数据的细颗粒分发信息，<code>HDG算法</code>还引入了一维网格去提供每个属性上的细粒度分发信息，并将来自一维和二维网格信息结合在一起去回答范围查询。</p>
<h3 id="3-4-2算法不足"><a href="#3-4-2算法不足" class="headerlink" title="3.4.2算法不足"></a>3.4.2算法不足</h3><p>相同粒度的网格不能处理用户数据的各种分布；</p>
<p>使用一维网格可能会破坏属性之间的相关性。</p>
<h2 id="3-5附注"><a href="#3-5附注" class="headerlink" title="3.5附注"></a>3.5附注</h2><h3 id="3-5-1设计目标"><a href="#3-5-1设计目标" class="headerlink" title="3.5.1设计目标"></a>3.5.1设计目标</h3><p>为整个域找到一个合理的分解策略去避免引入过量的噪声；</p>
<p>在拓展到多维场景时，设计的机制应该要比现有算法的有更高的查询精确度。</p>
<h3 id="3-5-2与现有算法的不同之处"><a href="#3-5-2与现有算法的不同之处" class="headerlink" title="3.5.2与现有算法的不同之处"></a>3.5.2与现有算法的不同之处</h3><p><code>AHEAD算法</code>是自适应且动态的算法；</p>
<p><code>AHEAD算法</code>减少了噪声对小区间结点的影响；</p>
<p><code>AHEAD算法</code>可以从一维拓展到高维场景中。</p>
<h1 id="4-AHEAD算法"><a href="#4-AHEAD算法" class="headerlink" title="4.AHEAD算法"></a>4.AHEAD算法</h1><h2 id="4-1动机和概述"><a href="#4-1动机和概述" class="headerlink" title="4.1动机和概述"></a>4.1动机和概述</h2><p>一方面，当回答查询需要结合多个小区间结点时，因为每个区间结点都需要满足LDP的隐私保证，所以都会引入噪声，当小区间结点过多时注入的噪声就会更加地多，为了解决这一问题，因此需要动态地结合不同的区间结点，进而减少注入的噪声量；</p>
<p>另一方面，当查询的范围是某个区间的一部分时，此时需要采用主流的均匀分布假设来回答查询，这时如果区间内分布不均匀就会引入不均匀误差；</p>
<p>综上分析，AHEAD算法应该试图平衡这两种误差，并解决现有算法的不足。</p>
<h2 id="4-2工作流程"><a href="#4-2工作流程" class="headerlink" title="4.2工作流程"></a>4.2工作流程</h2><h3 id="4-2-1采样方案的选择（Sampling-Principle）"><a href="#4-2-1采样方案的选择（Sampling-Principle）" class="headerlink" title="4.2.1采样方案的选择（Sampling Principle）"></a>4.2.1采样方案的选择（Sampling Principle）</h3><p>使用隐私预算时有两种策略：<code>隐私预算拆分策略</code>和<code>用户分区策略</code></p>
<p><code>隐私预算拆分策略（privacy budget splitting strategy）</code>：将整个隐私预算<code>𝜖</code>分成<code>c</code>份，并且在隐私预算<code>𝜖/c</code>下对所有用户的报告进行频率分布的估计；</p>
<p><code>用户分区策略（user partition strategy）</code>：随机地将用户分为<code>c</code>组，并使用整个隐私预算从魅族用户那里获取频率值；</p>
<p>对于相同的区间结点，两种策略的方差分别如下所示：</p>
<img data-src="/post/8d2d0774/5.png" class title="隐私预算拆分策略方差">

<img data-src="/post/8d2d0774/6.png" class title="用户分区策略方差">

<p>因为<code>𝜖&gt;0</code>且<code>c&gt;1</code>，所以<code>Var1&gt;Var2</code></p>
<blockquote>
<p>Ps：这两个方差的大小比较还没弄明白（待续）</p>
</blockquote>
<p>综上，<code>AHEAD算法</code>选择了<code>用户分区策略（user partition strategy）</code>。</p>
<h3 id="4-2-2算法流程"><a href="#4-2-2算法流程" class="headerlink" title="4.2.2算法流程"></a>4.2.2算法流程</h3><p><code>Step1：User Partition</code>：聚合器首先确定用户分区数量<code>c</code>，其中<b>c&#x3D;log<sub>B</sub>|D|</b>，然后用户在<code>[1, 2, ... , c]</code>中随机选择一个分区号（用户也可以使用其公共信息去选择分区号）。分区过程应该确保每个分区拥有相似的用户数量去代表总体人口；</p>
<p><code>Step2：Noisy Frequency Construction</code>：聚合器首先创建一个根节点<b>n<sub>0</sub></b>代表整个域，然后聚合器对整个域执行初始分解（即把整个域分解成<code>B</code>个大小相等的区间，<code>B</code>是树的分支数），并将分解得到的区间结点指向根节点<code>n&lt;sub&gt;0&lt;/sub&gt;</code>，此时根节点<code>n&lt;sub&gt;0&lt;/sub&gt;</code>的子结点代表整个域的划分方式<b>E<sub>1</sub></b>。之后聚合器选择第一个分区的用户并将<b>E<sub>1</sub></b>和隐私预算<code>𝜖</code>发送给用户。这时第一个分区的用户就会先扰动自己的隐私数据，并将扰动值通过<code>OUE</code>算法投入到<b>E<sub>1</sub></b>划分后得到的区间中。聚合器在收到用户的数据后就会使用聚合算法去获得频率估计分布<b>F<sub>1</sub></b>；</p>
<p><code>Step3：New Decomposition Generation</code>：聚合器得到区间的频率估计分布<b>F<sub>1</sub>&#x3D;{f<sub>1</sub>, f<sub>2</sub>}</b>之后，会根据阈值θ决定是否要对区间结点进一步分解。具体来说，如果某个频率<code>f</code>小于阈值<code>θ</code>，则不需要再进行分解；如果某个频率<code>f</code>大于阈值<code>θ</code>，则需要对该区间再次进行分解得到划分方式<b>E<sub>2</sub></b>并处理下一组用户；聚合器重复以上步骤知道所有的用户数据都已经处理完毕。在构造上述的原型树时没有考虑书中频率值的约束（子结点的频率值总和等于父节点的频率值），因此需要进行后处理；</p>
<p><code>Step4：Post-processing</code>：该步骤包含<code>非负</code>和<code>加权平均</code>（可以最大程度减少噪声的幅度）两步操作。<code>AHEAD算法</code>首先在相同层中通过<code>NormSub算法</code>使得结点的估计频率值都非负，且所有频率值的总和为<code>1</code>；然后自底向上计算非叶节点<code>n</code>和其子结点的加权平均值去更新<code>n</code>的频率估计值（通过结合<code>n</code>的多次估计来减少加性噪声）：</p>
<blockquote>
<p>对于非根节点<code>n</code>：</p>
<img data-src="/post/8d2d0774/8.png" class title="结点频率值更新">

<p>其中，参数设置如下（这样设置可以得到最小的更新方差）：</p>
<img data-src="/post/8d2d0774/9.png" class title="参数&lt;b&gt;𝜆&lt;sub&gt;1&lt;&#x2F;sub&gt;&lt;&#x2F;b&gt;">

<img data-src="/post/8d2d0774/10.png" class title="参数&lt;b&gt;𝜆&lt;sub&gt;2&lt;&#x2F;sub&gt;&lt;&#x2F;b&gt;">

<p>Var<sub>child(n)</sub>代表结点<code>n</code>的子结点的方差总和，Var<sub>n</sub>代表结点<code>n</code>的方差。<code>f~</code>代表<code>f^</code>的后处理版本</p>
</blockquote>
<blockquote>
<p>定理：使用上述方程对子结点进行组合时，结点<code>n</code>可以获得最小的更新方差</p>
<p>证明：（待续）</p>
</blockquote>
<p>最后，在结点区间均匀分布的假设下，自顶向下对频率值进行迭代分解以获得一颗用于回答范围查询的完全树，至此，<code>AHEAD算法</code>结束。</p>
<h2 id="4-3隐私和效用分析"><a href="#4-3隐私和效用分析" class="headerlink" title="4.3隐私和效用分析"></a>4.3隐私和效用分析</h2><h3 id="4-3-1隐私保证"><a href="#4-3-1隐私保证" class="headerlink" title="4.3.1隐私保证"></a>4.3.1隐私保证</h3><p><code>定理</code>：<code>AHEAD算法</code>满足<code>𝜖-LDP</code></p>
<p><code>证明</code></p>
<p><code>Step1</code>中，用户在<code>[1, 2, ... , c]</code>中随机地选取其分区，这一步没有隐私预算消耗；<code>Step2</code>和<code>Step3</code>中，<code>AHEAD算法</code>顺序地与用户进行交互，并且每个用户产生一个输出；<code>Step4</code>中，AHEAD算法没有触及用户地隐私数据，因此不会产生额外地隐私预算；因此，如果在和用户交互时（<code>Step3</code>和<code>Step4</code>）满足<code>𝜖-LDP</code>，那么<code>AHEAD算法</code>满足<code>𝜖-LDP</code>；</p>
<p>在每个交互时回合中，<code>AHEAD算法</code>都基于<code>Step2</code>中的隐私预算<code>𝜖</code>使用<code>OUE算法</code>构建嘈杂的频率；对于分区<code>g</code>中同一用户的任何一对可能值<b>v<sub>1</sub>, v<sub>2</sub>∈D</b>，加噪的二进制向量<code>O</code>为<code>OUE</code>范围内的潜在输出；</p>
<img data-src="/post/8d2d0774/11.png" class title="&#96;𝜖-LDP&#96;证明">

<p>上式中<code>l</code>是<code>O</code>的长度。根据上式可知，Step2满足<code>𝜖-LDP</code>，而由于<code>Step3</code>处理的是用户上传的加噪之后的数据（即没有使用用户原始的隐私数据），所以没有消费额外的隐私预算消费；</p>
<p>综上，<code>AHEAD算法</code>满足<code>𝜖-LDP</code></p>
<h3 id="4-3-2误差分析"><a href="#4-3-2误差分析" class="headerlink" title="4.3.2误差分析"></a>4.3.2误差分析</h3><p><code>AHEAD算法</code>的误差来源有三个：<code>噪声</code>、<code>采样误差</code>、<code>不均匀误差</code></p>
<p><code>噪声</code>和<code>采样误差</code>：来自<code>OUE</code>扰动和用户采样过程。虽然<code>OUE</code>算法可以得到频率估计值的无偏估计，但是仍然会存在由扰动导致的估计方差，而据研究分析，采样误差是一个远小于注入噪声的常数；</p>
<p><code>不均匀误差</code>：来自于一些区间，其频率值要通过较大的区间（父节点）来获得，而父节点并不一定满足均匀分布假设</p>
<p>综上，<code>AHEAD算法</code>的主要误差为<code>噪声</code>和<code>不均匀误差</code></p>
<h2 id="4-4B和θ的选择"><a href="#4-4B和θ的选择" class="headerlink" title="4.4B和θ的选择"></a>4.4B和θ的选择</h2><h3 id="4-4-1θ的选择"><a href="#4-4-1θ的选择" class="headerlink" title="4.4.1θ的选择"></a>4.4.1θ的选择</h3><p><code>θ</code>遵循以下式子进行设置：</p>
<img data-src="/post/8d2d0774/12.png" class title="&#96;θ&#96;的选择">

<img data-src="/post/8d2d0774/13.png" class title="&#96;Var&#96;">

<p><code>分析</code></p>
<p>首先使用在<code>HIO算法</code>中使用的策略去获得频率估计值和整体估计误差的期望，具体计算如下：</p>
<img data-src="/post/8d2d0774/14.png" class title="&#96;HIO算法&#96;误差">

<p>然后使用在<code>AHEAD算法</code>去获得整体估计误差的期望，具体计算如下：</p>
<img data-src="/post/8d2d0774/15.png" class title="&#96;AHEAD算法&#96;误差">

<p>然后令<code>AHEAD算法</code>的误差小于<code>HIO算法</code>的误差，得到以下不等式：</p>
<img data-src="/post/8d2d0774/16.png" class title="推导结果">

<p>综上，使用上述式子对<code>θ</code>进行设置时可以更好地减小估计误差</p>
<h3 id="4-4-2B的选择"><a href="#4-4-2B的选择" class="headerlink" title="4.4.2B的选择"></a>4.4.2B的选择</h3><p>分支因数<code>B</code>的作用在于平衡树的高度和回答查询需要的结点数量，<code>AHEAD算法</code>在考虑了不均匀误差的基础上将<code>B</code>设置为<code>2</code></p>
<p><code>分析</code></p>
<p>因为对数据的分布没有先验知识，所以对于不均匀误差应该考虑最坏情况，此时估计误差的期望为：</p>
<img data-src="/post/8d2d0774/17.png" class title="估计误差期望">

<p>对上式进行求导并另导函数为<code>0</code>，得到<code>B=0.6</code>或<code>B=2.2</code>。因为分支因数为大于<code>1</code>的整数，并且<code>B=2</code>比<code>B=3</code>的期望更小，所以最终设置<code>B=2</code></p>
<h2 id="4-5拓展到多维场景"><a href="#4-5拓展到多维场景" class="headerlink" title="4.5拓展到多维场景"></a>4.5拓展到多维场景</h2><h3 id="4-5-1二维范围查询"><a href="#4-5-1二维范围查询" class="headerlink" title="4.5.1二维范围查询"></a>4.5.1二维范围查询</h3><p>对于<code>AHEAD算法</code>，一维和二维的主要区别在于分解过程：对于一维场景，分解的总区间为<code>[1, |D|]</code>；对于二维场景，分解的总区间为<code>[1, |D|]x[1, |D|] </code>；</p>
<p>对于二维场景，<code>AHEAD算法</code>将<code>B</code>设置为<code>4</code>（每个维度的<code>B=2</code>），其具体的工作流程与一位范围查询基本相同。而为了减小随着结点使用数量不断增加而增加的查询误差，<code>AHEAD算法</code>更偏向于使用粗粒结点来回答查询（即自顶向下）</p>
<h3 id="4-5-2高维范围查询"><a href="#4-5-2高维范围查询" class="headerlink" title="4.5.2高维范围查询"></a>4.5.2高维范围查询</h3><p>AHEAD算法可以通过两种方式拓展到更高维度：<code>Direct Estimation</code>、<code>Leveraging Low-dimensional Estimation</code></p>
<p><code>Direct Estimation</code>：对于一颗分支因数为B&#x3D;2<sup>m</sup>的树，<code>AHEAD算法</code>同时在<code>m</code>个维度进行分解；该方法的不足在于随着维度的不断增加，叶节点的数量呈指数级增长，这使得对高维度数据集进行范围查询处理时变得相当耗时；</p>
<p><code>Leveraging Low-dimensional Estimation</code>：该算法对用户数据的数量进行结对组合，并对每一对属性对构建一颗二维<code>AHEAD树</code>；当回答一个<code>m</code>维的范围查询时，<code>LLE</code>构建了一个带有关联<b>2<sup>m</sup></b>个查询的查询集合，然后，以二维频率作为限制，<code>LLE</code>通过最大熵优化估算所有<b>2<sup>m</sup></b>个查询的频率值</p>
<blockquote>
<p><code>最大熵优化估算</code>：（待续）</p>
</blockquote>
<p>综上，<code>DE</code>方法的实现相对简单，并且用户分区的数量不会随维度的增加而增加。但是，在高维场景中，使用<code>DE</code>的<code>AHEAD树</code>可能非常大，这会使树的构造和进行范围查询的过程变得相当耗时。与<code>DE</code>相比，<code>LLE</code>将属性成对结合在一起，然后为每个属性对构造一个二维<code>AHEAD树</code>，这会使每棵树的规模都不太大。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h1><p>通过利用自适应层次分解，为一维和多维范围查询问题提出了一种新颖的<code>LDP</code>协议。<code>AHEAD算法</code>满足了严格的<code>LDP</code>保证，同时使用理论上衍生的参数实现了有利的实用性性能。通过理论分析以及广泛的实验评估，文章展示了<code>AHEAD算法</code>在范围查询方面平衡效用和隐私性的有效性及其在最新方法中的显着优势。此外，通过研究各种参数设置，文章得出了几种在实践中采用的重要观察。</p>
]]></content>
      <categories>
        <category>差分隐私（英文文献）</category>
      </categories>
      <tags>
        <tag>差分隐私</tag>
        <tag>Range Query</tag>
        <tag>频率估计</tag>
        <tag>边缘列联表发布</tag>
      </tags>
  </entry>
  <entry>
    <title>Answering Multi-Dimensional Analytical Queries under Local Differential Privacy</title>
    <url>/post/a9e145d2.html</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>该文献主要研究<code>LDP</code>下回答多维分析查询的问题（<code>MDA</code>），并提出了几种<code>LDP</code>编码器和频率估计算法去处理不同类型的<code>MDA查询</code>。该文献提出的技术能够在严格的误差范围内回答<code>MDA查询</code>，并在真实数据集和合成数据集上进行了相关实验进一步验证了理论分析结果。</p>
<span id="more"></span>

<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><h2 id="1-1数据模型和应用场景"><a href="#1-1数据模型和应用场景" class="headerlink" title="1.1数据模型和应用场景"></a>1.1数据模型和应用场景</h2><p>用户在使用云服务的过程中会产生一些多维数据，这些多维数据大致可以分为以下三部分：<code>measure attributes</code>、<code>sensitive</code>、<code>non-sensitive</code>。另一方面，云服务提供商希望能够在<code>sensitive</code>受到约束的情况下回答一些聚合<code>measure</code>的分析查询，以分析云服务的执行情况。尽管用户所有维度的数据不会全部公之于众，并且上述的分析过程在服务器端内部执行，但是云服务提供商需要提供一个运行在每个用户设备上的<code>LDP</code>数据收集算法，以确保<code>sensitive</code>维度得到妥善处理。</p>
<p>该文献研究的是如何（近似）回答一类多维分析查询（<code>MDA</code>），同时通过<code>LDP</code>收集每个用户的敏感数据。<code>MDA查询</code>就是对<code>measure attributes</code>进行聚合（<code>COUNT, SUM, AVG</code>）的<code>SQL</code>查询，且其约束条件（点约束和范围约束）作用在<code>sensitive</code>上。</p>
<h2 id="1-2解决方案概述"><a href="#1-2解决方案概述" class="headerlink" title="1.2解决方案概述"></a>1.2解决方案概述</h2><p><code>客户端</code>：每个用户拥有一些多维数据，他们使用LDP编码算法<b>A</b>对<code>sensitive</code>进行扰动，并将扰动后的数据上传给服务器；</p>
<p><code>服务器端</code>：从用户那里收集到进行<code>LDP</code>编码后的数据，然后再将其与其他服务器已知的数据和一些非敏感数据组合共同构成<code>fact table</code>（事实表）。 由于敏感维度是用注入的随机噪声编码的，因此需要一个算法 <b>P</b> 来估计查询结果。</p>
<h2 id="1-3挑战"><a href="#1-3挑战" class="headerlink" title="1.3挑战"></a>1.3挑战</h2><h3 id="1-3-1边缘列联表发布"><a href="#1-3-1边缘列联表发布" class="headerlink" title="1.3.1边缘列联表发布"></a>1.3.1边缘列联表发布</h3><p>在<code>LDP</code>下回答<code>MDA查询</code>与在<code>LDP</code>下发布边缘列联表（<code>marginal release</code>）的工作密切相关。一个边缘列联表记录了一系列维度之间的概率分布，其中表中的每一行类似于一个<code>COUNT</code>查询。因此可以通过对查询<code>Q</code>覆盖到的边缘列联表中的每一行进行求和来回答一个<code>MDA查询</code>。</p>
<p><code>挑战</code>：因为表中的每一行数据都被扰动过，即每行数据都带有噪声，那么查询结果每多加一行就会多增加一点噪声，因此该方法存在很大缺陷。一般来说，假设总共有<b>d</b>个有序维度，每个维度有<b>m</b>个不同的值，那么最坏情况下的平方误差会与<b>O(m<sup>d</sup>)</b>成正比，而当<b>m</b>很大时，最坏情况的误差可能会非常大。</p>
<h3 id="1-3-2频率估计"><a href="#1-3-2频率估计" class="headerlink" title="1.3.2频率估计"></a>1.3.2频率估计</h3><p>在<code>LDP</code>下回答<code>MDA查询</code>与在<code>LDP</code>下进行频率估计（<code>frequency oracle</code>）的工作同样密切相关。这种情景下，客户端每个用户有一个隐私值。此时用户会对敏感数据添加噪声进行<code>LDP</code>扰动， 然后再将扰动之后的数据上传给服务器。而服务器端则需要估计一个给定值的频率。实际上，一些简单的<code>MDA查询</code>（<code>COUNT</code>查询）可以被转换成频率估计问题。</p>
<p><code>挑战</code>：目前不知道如何通过频率估计解决其他聚合函数（<code>SUM, AVG</code>）的问题，以及如何在多个维度上处理复杂的范围约束条件而不会导致估计误差。</p>
<h2 id="1-4贡献"><a href="#1-4贡献" class="headerlink" title="1.4贡献"></a>1.4贡献</h2><p>（1）该文献提出了一种加权频率估计算法：将用户的<code>measure attributes</code>看作用户的权重，然后根据<code>measure attributes</code>对所有用户进行分组，并对每个组的用户个数计数后再将其乘上<code>measure attributes</code>，最后再执行聚合函数（<code>SUM, AVG, STDEV</code>）便完成了<code>MDA查询</code>；</p>
<p>（2）将加权频率估计算法融入到区间分层机制中，使得基于边缘列联表发布的最坏情况下的平方误差从<b>O(m<sup>d</sup>)</b>减少到<b>log<sup>O(d)</sup>m</b>；并将分解模式从一维扩展到了<code>d</code>维，使得误差仍然为<b>log<sup>O(d)</sup>m</b>；</p>
<p><code>两种方法</code>：一种是将隐私预算基于树的层数的对数级别进行分配；另一种是随机取样，然后将样本的频率估计结果放大为所有用户的频率估计结果；</p>
<p>（3）探究了当整个隐私维度很大但是查询包含的隐私维度很小时误差的优化方案。</p>
<h1 id="2-初步"><a href="#2-初步" class="headerlink" title="2.初步"></a>2.初步</h1><h2 id="2-1多维模型和分析"><a href="#2-1多维模型和分析" class="headerlink" title="2.1多维模型和分析"></a>2.1多维模型和分析</h2><p>每个用户的多维数据包含的一系列属性（<code>dimensions/measures</code>）构成一个元组<code>t</code>。在一个分析问题中，<code>dimension</code>用<code>D</code>表示，其出现在谓语中，<code>measure</code>用<code>M</code>表示，其出现在聚合函数中，因此<code>t[D]</code>和<code>t[M]</code>代表元组<code>t</code>中的某个属性值（<code>D</code>和<code>M</code>也可以代表属性的取值域<code>domain</code>）。</p>
<p><code>MDA查询</code>：如下图所示：</p>
<img data-src="/post/a9e145d2/1.png" class title="多维分析查询">

<p>① 聚合函数<code>F(M)</code>可以为<code>COUNT(*), SUM(M), AVG(M)</code>，因为<code>COUNT(*)</code>是一种特殊的聚合函数，且<code>AVG(M)</code>可以从其他两个聚合函数中推导得出，因此主要考虑<code>SUM(M)</code>函数；</p>
<p>② 谓语<code>C</code>由对分类维度的点约束（<b>D<sub>i</sub>&#x3D;v<sub>i</sub></b>）和对有序维度的范围约束（<b>D<sub>i</sub>∈[l<sub>i</sub>, r<sub>i</sub>]</b>）组成。</p>
<h2 id="2-2MDA查询流程"><a href="#2-2MDA查询流程" class="headerlink" title="2.2MDA查询流程"></a>2.2MDA查询流程</h2><p><code>客户端（LDP编码器A）</code>：每个用户采用满足<code>ε-LDP</code>的算法<b>A<sup>ε</sup></b>对其敏感维度进行处理，并将<b>A<sup>ε</sup>(t)</b>发送给服务器；</p>
<p><code>服务器端（估计处理器P）</code>：<b>n</b>个用户的数据元组构成一个事实表<b>T&#x3D;{t<sub>1</sub>, … , t<sub>n</sub>}</b>，而服务器实际从客户端收集到的表为<b>A(T)&#x3D;{A(t<sub>1</sub>), … , A(t<sub>n</sub>)}</b>。那么MDA查询<b>q&#x3D;Q<sub>T</sub>(F(M), C)</b>就可以根据<b>A(T)</b>和<b>T</b>的其他属性使用估计算法<b>P</b>近似进行回答，最终得到<b>P(q)</b>；</p>
<p><code>误差测量</code>：采用期望平方误差<b>Err(P(q))&#x3D;E[(P(q)-q)<sup>2</sup>]</b>，如果<b>P(q)</b>是<b>q</b>的无偏估计，那么<b>Err(P(q))&#x3D;Var(P(q))</b>。</p>
<h1 id="3-加权频率估计"><a href="#3-加权频率估计" class="headerlink" title="3.加权频率估计"></a>3.加权频率估计</h1><h2 id="3-1MDA查询的表示"><a href="#3-1MDA查询的表示" class="headerlink" title="3.1MDA查询的表示"></a>3.1MDA查询的表示</h2><p><code>MDA查询</code>的表示方式如下图所示：</p>
<img data-src="/post/a9e145d2/2.png" class title="加权频率估计">

<h2 id="3-2频率估计"><a href="#3-2频率估计" class="headerlink" title="3.2频率估计"></a>3.2频率估计</h2><h3 id="3-2-1未加权频率估计（FO）"><a href="#3-2-1未加权频率估计（FO）" class="headerlink" title="3.2.1未加权频率估计（FO）"></a>3.2.1未加权频率估计（FO）</h3><p>当所有用户均满足<b>t[M]&#x3D;1</b>时，<code>MDA查询</code><b>f<sup>M</sup><sub>S</sub>(v)</b>就相当于计算<b>v</b>的频率，即等同于一个<code>COUNT</code>查询：</p>
<img data-src="/post/a9e145d2/3.png" class title="COUNT查询">

<p><code>OLH</code>算法是一种拥有渐进最优误差的未加权频率估计算法，其主要流程为：首先从一个哈希函数族中随机选择一个哈希函数<code>H</code>，然后将用户数据中的属性<code>t[D]</code>从范围<code>D</code>映射到一个更小的范围<code>g</code>，并以一定的概率将<code>t[D]</code>扰动为<code>g</code>中某个值<code>y</code>，即<code>y=H(t[D])</code>。因此用户数据t经过LDP扰动后得到的LDP报文为<b>A<sub>FO</sub>(t[D])&#x3D;&lt;H, y&gt;</b>。<code>OLH</code>算法具体流程如下图所示：</p>
<img data-src="/post/a9e145d2/4.png" class title="OLH算法">

<blockquote>
<p>Ps：Client side第一步原文作者好像打错了，个人感觉应该是at random</p>
</blockquote>
<p>其中，下图所示的引理给出了<code>OLH</code>算法的渐进最优误差：</p>
<img data-src="/post/a9e145d2/5.png" class title="OLH算法渐进最优误差">

<h3 id="3-2-2加权频率估计（WFO）"><a href="#3-2-2加权频率估计（WFO）" class="headerlink" title="3.2.2加权频率估计（WFO）"></a>3.2.2加权频率估计（WFO）</h3><p>为了解决<code>MDA查询</code>，加权频率估计算法在<code>OLH</code>算法的基础上进行了相应调整，该算法的主要思想为将用户根据其<code>measures</code>进行分组，例如<b>S<sub>x</sub>&#x3D;{t∈S|t[M]&#x3D;x}</b>。对于一个维度值<b>v</b>，通过<b>S<sub>x</sub></b>建立<code>FO</code>与<code>WFO</code>之间的关系，如下图所示：</p>
<img data-src="/post/a9e145d2/6.png" class title="FO与WFO">

<p>加权频率估计算法的误差推导如下所示：</p>
<img data-src="/post/a9e145d2/7.png" class title="加权频率估计算法误差">

<h2 id="3-3随机样本放大"><a href="#3-3随机样本放大" class="headerlink" title="3.3随机样本放大"></a>3.3随机样本放大</h2><p>当只有某些随机样本被抽取去使用<b>A<sub>FO</sub></b>报告他们的私人值<code>t[D]</code>时，这种情况下首先需要使用<b>f<sup>M</sup></b>估计该样本中值<code>v</code>的加权频率，然后再将所估计的频率放大到所有用户。</p>
<blockquote>
<p>Ps：这一做法被作者使用在其所提出的SC机制中，实验指出该做法提升了性能</p>
</blockquote>
<p>具体来说，对于用户集合<code>S</code>，首先随机地将<code>S</code>分成<b>S<sub>1</sub>, … , S<sub>k</sub></b>总共<code>k</code>个组（其中<code>S</code>中的每个用户以概率<code>1/k</code>随机选择一个组<b>S<sub>i</sub></b>）；然后，只对一个样本（记作<b>S<sub>1</sub></b>）运行加权频率估计算法<b>(A<sub>FO</sub>, f<sup>M</sup>)</b>，那么就可以得到<b>S<sub>1</sub></b>这个组中<code>v</code>的频率估计，然后再放大<code>k</code>倍即可获取整个用户集合<code>S</code>中<code>v</code>的频率估计：</p>
<img data-src="/post/a9e145d2/8.png" class title="频率估计">

<p>据下图可知，上图式中等号左边的表达式是<b>f<sup>M</sup><sub>S</sub>(v)</b>的无偏估计：</p>
<img data-src="/post/a9e145d2/9.png" class title="无偏估计">

<p><code>误差</code>：该算法误差有两个来源，一个是来自LDP噪声，另一个是来自采样过程。下图推导了该算法的误差界限：</p>
<img data-src="/post/a9e145d2/10.png" class title="误差界限">

<h2 id="3-4通过边缘列联表回答MDA"><a href="#3-4通过边缘列联表回答MDA" class="headerlink" title="3.4通过边缘列联表回答MDA"></a>3.4通过边缘列联表回答MDA</h2><p>估计边缘列联表的机制主要关注<code>COUNT</code>查询，但实际上只需要做一些变换就可以用这些机制去处理<code>MDA查询</code>：为了回答一个<code>MDA查询</code>，首先要根据<code>measure</code> <code>M</code>将事实表<code>T</code>分为多个子表<b>T<sub>x</sub></b>，即<b>T<sub>x</sub>&#x3D;{t∈T|t[M]&#x3D;x}</b>；然后再根据估计得到的边缘列联表去计算每一个子标<b>T<sub>x</sub></b>中的满足限制条件<code>C</code>的元组（记作<b>n<sub>x</sub></b>），那么对于一个<code>SUM</code>类型的<code>MDA</code>查询，其结果可以通过<b>Σ<sub>x</sub> x n<sub>x</sub></b>进行求得。</p>
<p><code>不足</code>：如<code>1.3.1</code>所述，该方法会引入较大的误差。一般来说，假设<code>D∈[l, r</code>]中有<code>m</code>个不同的值，那么根据<code>3.2.2</code>该机制的误差为（线性依赖于<code>m</code>）：</p>
<img data-src="/post/a9e145d2/11.png" class title="误差">

<p><code>解决方案</code>：为了解决上述问题，<code>4-5节</code>提出了新的机制，使得最终的误差对数依赖于<code>m</code>。</p>
<h1 id="4-单隐私维度分析查询"><a href="#4-单隐私维度分析查询" class="headerlink" title="4.单隐私维度分析查询"></a>4.单隐私维度分析查询</h1><h2 id="4-1区间分层机制"><a href="#4-1区间分层机制" class="headerlink" title="4.1区间分层机制"></a>4.1区间分层机制</h2><h3 id="4-1-1区间分层"><a href="#4-1-1区间分层" class="headerlink" title="4.1.1区间分层"></a>4.1.1区间分层</h3><p>假设有序维度<code>D</code>有<code>m</code>个不同的值，顺序依次为<b>Z<sub>1</sub>, Z<sub>2</sub>, … , Z<sub>m</sub></b>，然后构建一颗完全<code>B</code>叉树，直到最后一层每个结点只包含一个值：第一层为<b>L<sup>0</sup>&#x3D;{[Z<sub>1</sub>, Z<sub>m</sub>]}</b>，其对应根节点；最后一层为<b>L<sup>h</sup>&#x3D;{[Z<sub>1</sub>, Z<sub>1</sub>], … , [Z<sub>m</sub>, Z<sub>m</sub>]}</b>。记<b>I<sub>D</sub>&#x3D;{L<sup>0</sup>, … , L<sup>h</sup>}</b>，其中<b>h&#x3D;log<sub>b</sub>m</b>。</p>
<h3 id="4-1-2通过区间分层重写查询"><a href="#4-1-2通过区间分层重写查询" class="headerlink" title="4.1.2通过区间分层重写查询"></a>4.1.2通过区间分层重写查询</h3><p>对于某个查询<b>q&#x3D;Q<sub>T</sub>(SUM(M), D∈[l, r])</b>，平均来说区间<b>[l, r]</b>可以被分解为<b>2(b-1)log<sub>b</sub>m</b>个不相交的子区间<b>I<sup>1</sup>, … , I<sup>p</sup></b>。因此查询<b>q</b>便可以相应地分解为基于这些子区间的子查询，而每一个子查询又可以通过加权频率估计算法进行频率估计，如下图所示：</p>
<img data-src="/post/a9e145d2/12.png" class title="重写查询">

<blockquote>
<p>Ps：<b>2(b-1)log<sub>b</sub>m</b>来源于普渡大学李宁辉教授的某篇文献（目前还没找到具体文献）</p>
</blockquote>
<h3 id="4-1-3HI机制（一维）"><a href="#4-1-3HI机制（一维）" class="headerlink" title="4.1.3HI机制（一维）"></a>4.1.3HI机制（一维）</h3><p><code>客户端</code>：首先隐私预算<b>ε</b>基于完全树的高度<b>h</b>均等地分成<b>h</b>份，那么每一层的隐私预算为<b>ε&#x2F;(log<sub>b</sub>m)</b>，然后用户对其敏感属性所在的每一层的对应区间都使用<code>OLH</code>算法进行<code>LDP</code>扰动，并将扰动之后的树发送给服务器；</p>
<p><code>服务器端</code>：首先将查询范围<b>D</b>进行重写，然后使用加权频率估计算法去估计每一个子查询，最后再进行求和，那么所得到的求和结果就是查询结果，如下图所示：</p>
<img data-src="/post/a9e145d2/13.png" class title="一维HI机制">

<p><code>误差</code>：根据以下理论可以得出<code>HI</code>机制的误差界限（根据<code>3.3.2</code>的误差推导出）：</p>
<img data-src="/post/a9e145d2/14.png" class title="一维HI机制误差">

<h2 id="4-2HIO机制（一维）"><a href="#4-2HIO机制（一维）" class="headerlink" title="4.2HIO机制（一维）"></a>4.2HIO机制（一维）</h2><p><code>HIO</code>机制采用<code>3.3</code>节的随机采样放大算法。在<code>HI</code>机制中，客户端将隐私预算对每一层进行平均分配；而在<code>HIO</code>机制中，则采用将用户随机分成<b>h</b>组（<b>h</b>为树的高度）：分组<b>S<sub>j</sub></b>中的用户（对应树的第<b>j</b>层）可以被看成是从整个用户集合<b>S</b>中以采样率<b>1&#x2F;h</b>得到，且<b>S<sub>j</sub></b>中的用户消耗所有的隐私预算，<code>HIO</code>机制具体如下图所示：</p>
<img data-src="/post/a9e145d2/15.png" class title="一维HIO机制">

<p><code>算法流程</code>：和HI机制一样，查询<b>q&#x3D;Q<sub>T</sub>(SUM(M), D∈[l, r])</b>仍然分解为多个子查询；而对于每个子查询所在的子区间的层数，那么就可以使用被分组到该层的用户进行分组频率估计，然后再放大h倍作为该子查询的结果；</p>
<p><code>误差</code>：根据以下理论可以得出<code>HIO</code>机制的误差界限：</p>
<img data-src="/post/a9e145d2/16.png" class title="一维HIO机制误差">

<h1 id="5-多隐私维度分析查询（MDA）"><a href="#5-多隐私维度分析查询（MDA）" class="headerlink" title="5.多隐私维度分析查询（MDA）"></a>5.多隐私维度分析查询（MDA）</h1><h2 id="5-1有序维度-有序维度"><a href="#5-1有序维度-有序维度" class="headerlink" title="5.1有序维度+有序维度"></a>5.1有序维度+有序维度</h2><h3 id="5-1-1多维度区间分层"><a href="#5-1-1多维度区间分层" class="headerlink" title="5.1.1多维度区间分层"></a>5.1.1多维度区间分层</h3><p><code>二维</code>：二维区间定义为两个一维区间的笛卡儿积，如下图所示：</p>
<img data-src="/post/a9e145d2/17.png" class title="二维区间定义">

<p>一般来说，区间<b>[l<sub>1</sub>, r<sub>1</sub>]</b>可以分解成<b>p<sub>1</sub></b>个不相交的子区间，区间<b>[l<sub>2</sub>, r<sub>2</sub>]</b>可以分解成<b>p<sub>2</sub></b>个不相交的子区间，那么查询<b>q</b>便可以如下图所示进行分解：</p>
<img data-src="/post/a9e145d2/18.png" class title="二维查询分解">

<p><code>d维</code>：根据二维查询的分解方式，可以得到下图所示的<b>d</b>维查询的分解方式：</p>
<img data-src="/post/a9e145d2/19.png" class title="d维查询分解">

<h3 id="5-1-2HI机制（多维）"><a href="#5-1-2HI机制（多维）" class="headerlink" title="5.1.2HI机制（多维）"></a>5.1.2HI机制（多维）</h3><p><code>算法流程</code>：多维<code>HI</code>机制流程如下图所示：</p>
<img data-src="/post/a9e145d2/20.png" class title="多维HI机制">

<p><code>误差</code>：多维<code>HI</code>机制误差分析如下图所示：</p>
<img data-src="/post/a9e145d2/21.png" class title="多维HI机制误差">

<h3 id="5-1-3HIO机制（多维）"><a href="#5-1-3HIO机制（多维）" class="headerlink" title="5.1.3HIO机制（多维）"></a>5.1.3HIO机制（多维）</h3><p><code>算法流程</code>：多维<code>HIO</code>机制流程如下图所示：</p>
<img data-src="/post/a9e145d2/22.png" class title="多维HIO机制">

<p><code>误差</code>：多维<code>HIO</code>机制误差分析如下图所示：</p>
<img data-src="/post/a9e145d2/23.png" class title="多维HIO机制误差">

<h2 id="5-2有序维度-分类维度"><a href="#5-2有序维度-分类维度" class="headerlink" title="5.2有序维度+分类维度"></a>5.2有序维度+分类维度</h2><p>对于某个分类维度<b>D</b>，可以将其看作成一颗只有两层的树：第一层为一个包含所有取值的根节点，第二层则根据<b>D</b>中不同的值分解为多个只包含一个维度值的结点。通过这种分解转化，那么分类维度同样可以被看作成有序维度去处理。</p>
<h2 id="5-3SC机制"><a href="#5-3SC机制" class="headerlink" title="5.3SC机制"></a>5.3SC机制</h2><p>可以看到<code>HI</code>机制和<code>HIO</code>机制所产生的误差随着查询维度数量<b>d<sub>q</sub></b>和总隐私维度数量<b>d</b>的增长呈现指数级增长，于是作者想探究当查询维度数量<b>d<sub>q</sub></b>远小于总隐私维度数量<b>d</b>时，是否可能去除误差对总隐私维度数量<b>d</b>的依赖。</p>
<p><code>主要思想</code>：与<code>HI</code>机制不同的是，<code>SC</code>机制对<b>d</b>个隐私维度独立编码和上传，那么这种情况下就需要考虑如何将所有独立上传的维度串联起来去完成多维度查询。</p>
<h3 id="5-3-1状态变量及其转移"><a href="#5-3-1状态变量及其转移" class="headerlink" title="5.3.1状态变量及其转移"></a>5.3.1状态变量及其转移</h3><p>作者根据下图定义了输入状态和输出状态：</p>
<img data-src="/post/a9e145d2/24.png" class title="输入&#x2F;输出状态">

<p>根据输入状态和输出状态便可以定义下图所示的一维转移概率：</p>
<img data-src="/post/a9e145d2/25.png" class title="一维转移概率">

<p>依次类推，便可以定义下图所示的二维转移概率：</p>
<img data-src="/post/a9e145d2/26.png" class title="二维转移概率">

<h3 id="5-3-2通过转移矩阵进行频率估计"><a href="#5-3-2通过转移矩阵进行频率估计" class="headerlink" title="5.3.2通过转移矩阵进行频率估计"></a>5.3.2通过转移矩阵进行频率估计</h3><p><code>主要思想</code>：根据用户集合<b>S</b>及其<code>LDP</code>报文便可以得出每个二维输出状态的频率，然后借助转移矩阵便可得出每个二维输入状态的频率（其中还可以采用加权频率估计算法），如下图所示：</p>
<img data-src="/post/a9e145d2/27.png" class title="通过转移矩阵进行频率估计">

<blockquote>
<p>转移矩阵是确定的，使用OLH算法可以求出转移矩阵每个元素的值</p>
</blockquote>
<p><code>多维</code>：二维与多维唯一的区别在于转移矩阵的大小发生了变化，当隐私维度是<b>d</b>维时，转移矩阵的大小为<b>2<sup>d</sup>x2<sup>d</sup></b>。</p>
<p><code>频率估计器误差</code>：如下图所示：</p>
<img data-src="/post/a9e145d2/28.png" class title="频率估计器误差">

<h3 id="5-3-3SC机制"><a href="#5-3-3SC机制" class="headerlink" title="5.3.3SC机制"></a>5.3.3SC机制</h3><p><code>算法流程</code>：多维<code>SC</code>机制流程如下图所示：</p>
<img data-src="/post/a9e145d2/29.png" class title="多维SC机制">

<p><code>误差</code>：多维<code>HI</code>机制误差分析如下图所示：</p>
<img data-src="/post/a9e145d2/30.png" class title="多维SC机制误差">
]]></content>
      <categories>
        <category>差分隐私（英文文献）</category>
      </categories>
      <tags>
        <tag>差分隐私</tag>
        <tag>Range Query</tag>
        <tag>频率估计</tag>
        <tag>边缘列联表发布</tag>
        <tag>MDA</tag>
      </tags>
  </entry>
  <entry>
    <title>Implementing the Exponential Mechanism with Base-2 Differential Privacy</title>
    <url>/post/b63ba420.html</url>
    <content><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>现如今差分隐私有很好的理论支持，但是实现却仍是一个挑战，因为差分隐私的理论机制是任意或无限精度的，而在差分隐私具体的实现过程中采用的却是浮点或者固定精度。显然，差分隐私从理论到实际的这一转换过程肯定会存在一些问题，而这一点可能会成为攻击者实施攻击的一种手段。本文提出的方法将差分隐私定义中的基数e转换成基数2，而因为计算机是二进制的，这样转换之后就可以精确地执行算法，且时空复杂度较低。</p>
<span id="more"></span>

<h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>首先介绍了差分隐私理论（一个理论上十分严格的隐私框架，要求同一查询对邻近数据库的结果不可区分）（邻近数据库：两个数据库之间只相差一个条目）的提出背景；</p>
<p><code>差分隐私的定义源自</code>：KL散度，最大散度，<em>δ</em>-近似最大散度</p>
<p>差分隐私可以保证数据库中每个个体的隐私，并且对于与其他隐私机制的后处理也是健壮的；但是构建DP系统或机制可能具有挑战性，像拉普拉斯这类的添加噪声的机制容易受到机制规范和有限精度算法之间的转换问题的影响，而且在有限精度值上添加不精确计算产生的噪声可能会泄露原始值的重要信息。</p>
<p><code>指数机制</code>：不同于拉普拉斯机制，指数机制从一个固定的公共已知结果集中采样，选择每个结果的概率与一个由隐私数据决定的效用值u成比例。人们最初认为该机制不会受到基于浮点的攻击，然而一种基于不精确的浮点算术攻击可能对该机制造成影响。因此本文提出将e作为基数转换到2为基数，然后阐述了本文的核心概念贡献和主要技术贡献。</p>
<h5 id="1-1差分隐私初步"><a href="#1-1差分隐私初步" class="headerlink" title="1.1差分隐私初步"></a>1.1差分隐私初步</h5><p>引用前人提出的纯差分隐私，敏感度和拉普拉斯机制，指数机制等相关概念；</p>
<p>Note: 为了实现拉普拉斯机制，必须以任意精度从拉普拉斯分布中取样，而这在实践中肯定是有问题的，因为浮点数不能表示拉普拉斯分布中的每一个可能的值，而这可以被恶意方通过检查结果的最低位进行攻击，即这种攻击得以进行的原因是浮点计算的不精确导致对邻近数据库的查询结果是不同的，幸运的是，这种在拉普拉斯机制上的攻击可以通过细致的计算得到缓解。</p>
<h4 id="2-推翻指数机制"><a href="#2-推翻指数机制" class="headerlink" title="2.推翻指数机制"></a>2.推翻指数机制</h4><p>根据浮点数的IEEE表示阐明指数机制的简单实现如何被破坏：一种是不为0的两个很小的数相乘的结果下溢为0；另一种是数量级不同的两个数相加，因为较大的数要占据所有的精度位，所以较小的数被截断。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指数机制的python朴素实现</span></span><br><span class="line"><span class="comment"># Note: weights计算为什么多除了2; c_weights计算括号位置有问题</span></span><br><span class="line"><span class="comment"># The naive exponential mechanism</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># Inputs :</span></span><br><span class="line"><span class="comment"># eps : the privacy parameter ε</span></span><br><span class="line"><span class="comment"># u : the utility function 效用函数</span></span><br><span class="line"><span class="comment"># O : the set of outputs 输出结果集合</span></span><br><span class="line"><span class="comment"># Returns : an element in O 返回O中的一个元素</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">naive_exp_mech</span> (eps, u, O):</span><br><span class="line">	<span class="comment"># compute the weight of each element 计算每个元素的权重</span></span><br><span class="line">	weights = [np.exp(-(eps/<span class="number">2.0</span>) * u(o)) <span class="keyword">for</span> o <span class="keyword">in</span> O]</span><br><span class="line">    <span class="comment"># 计算总权重</span></span><br><span class="line">    T = <span class="built_in">sum</span>(weights)</span><br><span class="line">    <span class="comment"># cumulative weights 计算累积权重</span></span><br><span class="line">    c_weights = [<span class="built_in">sum</span>(weights [<span class="number">0</span>: i])/ T <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">1</span> , <span class="built_in">len</span> (O) +<span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># uniform sample from [0 ,1) 随机取出index</span></span><br><span class="line">    index = np.random.rand() </span><br><span class="line">    <span class="comment"># return element corresponding to the random index 根据随机取出的index返回元素</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">0</span>, <span class="built_in">len</span>(O)):</span><br><span class="line">    	<span class="keyword">if</span> c_weights[i] &gt; index :</span><br><span class="line">    		<span class="keyword">return</span> O[i]</span><br></pre></td></tr></table></figure>

<p><code>上述指数机制被破坏的两种场景转化位以下两种攻击方式</code></p>
<p><code>Zero-rounding</code></p>
<p>假设攻击者希望知道Alice是否在数据库中。攻击者选择一个结果空间O&#x3D;[O0, O1]，以及一个效用函数：如果Alice在数据库中，那么𝑢(𝑜0) &#x3D; 𝑥 且 𝑢(𝑜1) &#x3D; 𝑥 + 1；如果Alice不在数据库中，那么𝑢(𝑜0) &#x3D; 𝑥 + 1 且 𝑢(𝑜1) &#x3D; 𝑥。（以上场景中u的敏感度是1）。攻击者然后设置𝑥，使得np.exp(−(eps&#x2F;2) ∗ x) &gt; 0 但是np.exp(−(eps&#x2F;2) ∗ (x + 1)) &#x3D; 0。攻击者这样设置之后，如果Alice在数据库中，那么会得到结果O0的权重大于零，而结果O1的权重等于零，那么唯一可行结果就是O0；反之唯一可行结果就是O1。这样攻击者基本上可以确定Alice是否在数据库中。</p>
<p>Note：攻击者可以这样设置的原因就在于对x+1的权重进行计算时，计算出来的权重可能特别小以至于只能用0进行表示；而对x的权重进行计算时却正常</p>
<p>有人会说：只要保证所有元素的权值都大于零，那这种攻击就无效了</p>
<p><code>Truncated addition</code></p>
<p>攻击者选择两个值𝑥𝑙 和 𝑥𝑠，以及结果空间O&#x3D;[k]，使得XXX成立。攻击者然后选择一个效用函数使得：如果Alice不在数据库中，那么𝑢(𝑜1) &#x3D; 𝑥𝑙 + 1 且 𝑢(𝑜𝑖&gt;1) &#x3D; 𝑥𝑠；如果Alice在数据库中，那么𝑢(𝑜1) &#x3D; 𝑥𝑙 且 𝑢(𝑜𝑖&gt;1) &#x3D; 𝑥𝑠 +1。攻击者这样设置之后，如果Alice在数据库中，因为结果O1的概率非常的大，甚至等于总权重t，所以唯一可行结果就是O1。</p>
<p>Note：攻击者可以这样设置的原因就在于对𝑥𝑠 +1进行权重计算时，计算出来的权重比起𝑥𝑙计算出来的权重太小以至于可以忽略</p>
<p>一个解决办法：可以在机制执行的过程中监视每一次加法，但是这样的监视是非平凡的，因为e^x不能在有限位数内精确表达使得加法不能精确执行</p>
<p><code>缓解攻击方法一：将允许的效用值限制在一个范围内，使得在最小和最大可能权值内可以安全进行加法计算</code></p>
<p>但是要怎么把效用值限制在一个范围内？不精确的计算对隐私有什么影响？声明一个安全的范围确定的效用函数集的关键问题在于难以描述由于不精确计算带来的隐私损失，而且我们对实现的隐私损失作出的一般保证都是悲观的。</p>
<p><code>缓解攻击方法二：将分析限制在一组以前审查过的效用函数或工具上</code></p>
<p>但是即使是具有容易理解的灵敏度特性的简单小工具，例如标量乘法或加法，也可以用来构造上述攻击。</p>
<h4 id="3-精确实现指数机制"><a href="#3-精确实现指数机制" class="headerlink" title="3.精确实现指数机制"></a>3.精确实现指数机制</h4><p>针对上述问题，提出一个简单、精确的指数机制实现，并列出结果的四个贡献：</p>
<p>（1）定义base-2 DP，说明base-2和base-e之间的关系，并且证明当正确实现base-2指数机制时可以给出一个精确的隐私保证</p>
<p>（2）如何选择隐私参数和处理非整数效用函数（随机舍入），关键点在于随机舍入不会因为不精确的实现带来隐私损失，因为可以证明隐私损失原子最坏情况的舍入行为</p>
<p>（3）不使用除法从归一化概率中进行采样</p>
<p>（4）实现（python，Rust）</p>
<h5 id="3-1Base-2差分隐私"><a href="#3-1Base-2差分隐私" class="headerlink" title="3.1Base-2差分隐私"></a>3.1Base-2差分隐私</h5><p>这一动机源自观察，即计算机非常擅长于精确的二进制计算。本文不计算e^x，反之合适地选择一个y并计算2^y，使得从隐私角度能实现相同的结果，同时仍然能够利用精确的浮点运算。</p>
<p>根据Base-e差分隐私提出Base-2差分隐私（以及Base-2的指数机制），并阐明两者之间的关系：满足𝜂|2-DP的所有机制一定满足ln(2)𝜂−DP</p>
<h5 id="3-2非整数隐私参数和有效性（22-x2F-04-x2F-19-page5）"><a href="#3-2非整数隐私参数和有效性（22-x2F-04-x2F-19-page5）" class="headerlink" title="3.2非整数隐私参数和有效性（22&#x2F;04&#x2F;19 page5）"></a>3.2非整数隐私参数和有效性（22&#x2F;04&#x2F;19 page5）</h5><p><code>整数效用值情形下隐私参数的选择</code></p>
<p>第一，描述一个𝜂的大的集合（2^−𝜂可以精确计算）；第二，在这个集合中表达2^−𝜂的精度位数不会太大</p>
<p>对于一个二进制q和一个整数n，q^n最多需要max(1, bq<em>n)个精度位；因此对于2^(−𝜂) &#x3D; (x</em>2^(-y))^z，最多需要的精度位数为z*(y+bx)，所以对于(2^(−𝜂))^𝑢，最多需要的位数为max(1, u<em>z</em>(y+bx))</p>
<p>因为当设置z&#x3D;1且选择小的y时，𝜂的范围还是很大，所以实际上主要关注点就是𝑢的数量级，即控制精度的主要考虑时效用值的范围：自然的想法时直接给一个预规定的𝑢的一个可接受范围，并将观测到的效用值都限制到这个范围中（只要这个范围独立于隐私数据库，那么限制这个范围就不会给隐私保证带来影响）</p>
<p><code>确定最小精度的两种途径</code><br>（1）以给定的精度运行机制，如果执行的算法不精确，则以更高的精度重复该机制</p>
<p>（2）在运行机制前，对允许的效用值和结果空间大小使用公共指定边界，从而确定最小精度</p>
<p><code>第二种途径有两种方法</code><br>（1）最坏情况的理论分析：源自引理3.4，该引理得出最坏情况下计算权重组合所需精度的最坏情况下的边界。这一方法的缺点是它忽略了浮点表示中任何可能的抵消或效率</p>
<p>（2）最坏情况的经验程序：计算每一种假设的最坏情况并报道其所需精度。这种情况下就可以保证有充足的精度位去计算（a）每一个结果的权重；（b）最大可能结果的权重 + 一个有着最高小数精度位的权重。</p>
<p>因为尾数需要的最大尾数由最大可能权重和与表示任何单个权重所需的最高小数精度所决定</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 算法一：确定最小精度</span></span><br><span class="line"><span class="comment"># 输入：𝑢𝑚𝑖𝑛：最小效用值, 𝑢𝑚𝑎𝑥：最大效用值,𝑜𝑚𝑎𝑥：最大结果个数, 𝜂：隐私参数</span></span><br><span class="line"><span class="comment"># 输出：p：一个足够的精度，它不超过最小精度大小的两倍且可以成功运行base-2的指数机制</span></span><br><span class="line">procedure ComputePrecision(𝑢𝑚𝑖𝑛, 𝑢𝑚𝑎𝑥, 𝑜𝑚𝑎𝑥, 𝜂)</span><br><span class="line">	<span class="comment"># 初始化为1</span></span><br><span class="line">	𝑝 ← <span class="number">1</span></span><br><span class="line">    <span class="comment"># 如果检测精度失败则p加倍，并再次进行检测</span></span><br><span class="line">	<span class="keyword">while</span> CheckPrecision(𝑢𝑚𝑖𝑛, 𝑢𝑚𝑎𝑥, 𝑜𝑚𝑎𝑥, 𝜂, 𝑝) fails do</span><br><span class="line">		𝑝 ← <span class="number">2</span>𝑝</span><br><span class="line">	<span class="keyword">return</span> 𝑝</span><br><span class="line"><span class="comment"># 一旦程序中存在不精确计算就会返回failure</span></span><br><span class="line">function CheckPrecision(𝑢𝑚𝑖𝑛, 𝑢𝑚𝑎𝑥, 𝑜𝑚𝑎𝑥, 𝑏𝑎𝑠𝑒, 𝑝)</span><br><span class="line">	<span class="type">Set</span> the precision to 𝑝</span><br><span class="line">	<span class="keyword">return</span> failure on inexact arithmetic <span class="keyword">for</span>:</span><br><span class="line">	𝑚𝑎𝑥𝑠𝑢𝑚 ←𝑖∈[𝑜𝑚𝑎𝑥] <span class="number">2</span>^(−𝜂𝑢𝑚𝑖𝑛)</span><br><span class="line">	<span class="keyword">for</span> 𝑢∈[𝑢𝑚𝑖𝑛, 𝑢𝑚𝑎𝑥] do</span><br><span class="line">		𝑐𝑜𝑚𝑏𝑖𝑛𝑒𝑑𝑠𝑢𝑚 ← <span class="number">2</span>^(−𝜂𝑢) + ⌈𝑚𝑎𝑥𝑠𝑢𝑚⌉</span><br></pre></td></tr></table></figure>

<p><code>非整数效用值情形下隐私参数的选择</code></p>
<p>这种情况下采用的解决方法是：采用随即舍入，即向上或向下四舍五入到最接近的整数，其概率与整数的接近程度成正比。</p>
<p>基本策略：表明随机舍入不会因为不精确的实现而带来隐私损失</p>
<p>随机舍入指数机制会先分配一个整数代理效用值，然后再用这个值当作效用值进行之后的运算。</p>
<p>引理：具有任意精度随机舍入功能的指数机制是满足差分隐私的，这一论点来源于考虑最坏的舍入选择集，并认为隐私损失并不比这种情况更糟。</p>
<p>虽然随机舍入不会因为低精度的实现带来隐私损失，但是这一机制在多大程度上接近于原始的非整数效用方法还不是很明显。</p>
<p>命题3.6指出随即舍入不会很大程度地改变概率</p>
<h5 id="3-3不用除法进行归一化采样"><a href="#3-3不用除法进行归一化采样" class="headerlink" title="3.3不用除法进行归一化采样"></a>3.3不用除法进行归一化采样</h5><p>除法的问题在于：即使被除数和除数都可以用很小的二进制位精确表示，但是它们的商却不能被简单地表示。为此，提出了两种不采用除法的归一化方法</p>
<p><code>第一种方法</code></p>
<p>该方法源自观察：从[0, 𝑡)中均匀随机取样等同于从归一化分布中随机取样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 算法二：不使用除法进行权重归一化采样</span></span><br><span class="line"><span class="comment"># 输入：W：一个权重集合</span></span><br><span class="line"><span class="comment"># 输出：i：根据权重选出的采样下标</span></span><br><span class="line">procedure NormalizedSample(𝑊)</span><br><span class="line">	<span class="comment"># 计算总权重</span></span><br><span class="line">	𝑡 ← ∑𝑤∈𝑊 𝑤</span><br><span class="line">	𝑠 ← GetRandomValue(𝑝, 𝑡)</span><br><span class="line">    <span class="comment"># 计算累积权重</span></span><br><span class="line">	<span class="keyword">for</span> 𝑖 ∈ &#123;<span class="number">1</span>,...,|𝑊|&#125; do</span><br><span class="line">		𝑐𝑖 ← ∑𝑖,𝑗=<span class="number">1</span> 𝑤𝑗</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>&#123;𝑖|𝑐𝑖 &gt; 𝑠&#125;</span><br><span class="line"><span class="comment"># 输入：p:精度位数，t：范围上限</span></span><br><span class="line"><span class="comment"># 输出：一个从[0, 𝑡)中均匀随机采样取出的数</span></span><br><span class="line">function GetRandomValue(𝑝, 𝑡)</span><br><span class="line">	<span class="comment"># argmax：取最大值函数，求出g</span></span><br><span class="line">	𝑔 ← arg <span class="built_in">max</span> 𝑔&#123;<span class="number">2</span>^𝑔 ≤ 𝑡&#125;</span><br><span class="line">    <span class="comment"># 初始化s</span></span><br><span class="line">	Initialize 𝑠 ← ∞</span><br><span class="line">    <span class="comment"># 如果s不在[0, 𝑡)内则继续循环</span></span><br><span class="line">	<span class="keyword">while</span> 𝑠 ≥ 𝑡 do</span><br><span class="line">		<span class="keyword">for</span> 𝑖 ∈ &#123;<span class="number">1</span>,...,𝑝&#125; do</span><br><span class="line">        	<span class="comment"># 简单均匀随机取样</span></span><br><span class="line">			𝑟𝑖 ∼ Unif(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		𝑠 ←∑𝑝,𝑖=<span class="number">0</span> 𝑟𝑖*<span class="number">2</span>^(𝑔−𝑖)</span><br><span class="line">	<span class="keyword">return</span> 𝑠</span><br></pre></td></tr></table></figure>

<p><code>第二种方法</code></p>
<p>在范围[0, 𝑡)中通过在每一步丢弃一半的剩余范围执行随机的二分查找，当只剩余一个有效元素时停止。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 算法三：权重归一化采样算法</span></span><br><span class="line"><span class="comment"># 输入：W：一个权重集合</span></span><br><span class="line"><span class="comment"># 输出：i：根据权重选出的采样下标</span></span><br><span class="line">procedure NormalizedSample(𝑊)</span><br><span class="line">	<span class="comment"># 计算总权重</span></span><br><span class="line">	𝑡 ←∑𝑤∈𝑊 𝑤</span><br><span class="line">    <span class="comment"># 计算累积权重</span></span><br><span class="line">	<span class="keyword">for</span> 𝑖 ∈ &#123;<span class="number">1</span>,...,|𝑊|&#125; do</span><br><span class="line">		𝑐𝑖 ←∑𝑖,𝑗=<span class="number">1</span> 𝑤𝑗</span><br><span class="line">	𝑘 ← arg <span class="built_in">min</span>𝑘&#123;<span class="number">2</span>^𝑘 ≥ 𝑡 &#125; ⊲ The smallest power of two ≥ 𝑡.</span><br><span class="line">	<span class="keyword">if</span> <span class="number">2</span>^𝑘 &gt; 𝑡 then</span><br><span class="line">		𝑊 ← 𝑊 ∪ &#123;⊥&#125; ⊲ Add element ⊥ <span class="keyword">with</span> weight <span class="number">2</span>^𝑘 − 𝑡.</span><br><span class="line">		𝑐|𝑊| ← <span class="number">2</span>^𝑘 − 𝑡 ⊲ Total weight <span class="keyword">is</span> now <span class="number">2</span>^𝑘.</span><br><span class="line">	𝑠 ← <span class="number">0</span></span><br><span class="line">	𝑗 ← 𝑘 − <span class="number">1</span></span><br><span class="line">	𝑅 ← [|𝑊|] ⊲ the remaining elements</span><br><span class="line">	<span class="keyword">while</span> |𝑅| &gt; <span class="number">1</span> do</span><br><span class="line">		𝑟𝑗 ∼ Unif(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		𝑠 ← 𝑠 + 𝑟𝑗*<span class="number">2</span>^𝑗</span><br><span class="line">		<span class="keyword">for</span> 𝑖 ∈ 𝑅 do</span><br><span class="line">			<span class="keyword">if</span> 𝑐𝑖 ≤ 𝑠 then ⊲ 𝑠 cannot be <span class="keyword">in</span> [𝑐𝑖−<span class="number">1</span>, 𝑐𝑖), even <span class="keyword">if</span> <span class="built_in">all</span> draws are <span class="number">0.</span></span><br><span class="line">				𝑅 ← 𝑅\&#123;𝑖&#125;</span><br><span class="line">			<span class="keyword">if</span> 𝑖 &gt; <span class="number">0</span> <span class="keyword">and</span> 𝑐𝑖−<span class="number">1</span> ≥ 𝑠 + <span class="number">2</span>𝑗 then ⊲ 𝑠 cannot be <span class="keyword">in</span>[𝑐𝑖−<span class="number">1</span>, 𝑐𝑖), even <span class="keyword">if</span> maximum value added.</span><br><span class="line">				𝑅 ← 𝑅\&#123;𝑖&#125;</span><br><span class="line">		𝑗 ← 𝑗 − <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> |𝑅| = <span class="number">1</span> <span class="keyword">and</span> ⊥ ∈ 𝑅 then ⊲ Restart <span class="keyword">if</span> dummy value.</span><br><span class="line">			𝑠 ← <span class="number">0</span></span><br><span class="line">			𝑗 ← 𝑘 − <span class="number">1</span></span><br><span class="line">			𝑅 ← [|𝑊|]</span><br><span class="line"><span class="keyword">return</span> 𝑙</span><br></pre></td></tr></table></figure>

<p>引理3.7证明算法二和算法三等同于指数机制采样，且程序有很大概率最多使用O(p)的随机位数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 算法四：用最小的拒绝次数进行GETRANDOMVALUE操作</span></span><br><span class="line"><span class="comment"># 输入：p:精度位数，t：范围上限</span></span><br><span class="line"><span class="comment"># 输出：一个从[0, 𝑡)中均匀随机采样取出的数</span></span><br><span class="line">function GetRandomValue(𝑝, 𝑡)</span><br><span class="line">	𝑔 ← ⌊log2(𝑡)⌋</span><br><span class="line">	Initialize 𝑠 ← ∞, s∗ ← ∞, c ← <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> 𝑠 ≥ 𝑡 <span class="keyword">and</span> c &lt; k do ⊲ Reject 𝑠 <span class="keyword">if</span> it falls outside [<span class="number">0</span>, 𝑡) <span class="keyword">or</span> fewer than 𝑘 iterations.</span><br><span class="line">		<span class="keyword">for</span> 𝑖 ∈ &#123;<span class="number">1</span>, . . . , 𝑝&#125; do</span><br><span class="line">			𝑟𝑖 ∼ Unif(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		𝑠 ← ∑𝑝,𝑖=<span class="number">1</span>𝑟𝑖<span class="number">2</span>^(𝑔−𝑖)</span><br><span class="line">		<span class="keyword">if</span> 𝑠∗ = ∞ <span class="keyword">and</span> 𝑠 &lt; 𝑡 then</span><br><span class="line">			𝑠∗ ← 𝑠 ⊲ update 𝑠∗<span class="keyword">if</span> 𝑠 <span class="keyword">is</span> <span class="keyword">in</span> <span class="built_in">range</span>.</span><br><span class="line">		𝑐 ← 𝑐 + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> 𝑠∗</span><br></pre></td></tr></table></figure>

<h4 id="4-实现"><a href="#4-实现" class="headerlink" title="4.实现"></a>4.实现</h4><p><code>精确计算</code></p>
<p>采用GNU多重精度算法(GMP)和GNU MPFR库来实现高精度整数和浮点运算，通过python和rust语言访问这些库。这些库也提供了在运行时确定在给定系统上可实现的最大精度，避免由于超过任何系统特定的阈值而引发的错误的产生，且使得代码更容易进行审查。</p>
<p>MPFR提供了一组有用的标识符来指示操作不精确，结果溢出，下溢等问题</p>
<p><code>分离数据独立和数据依赖的逻辑</code></p>
<p><code>确定隐私参数</code></p>
<p><code>随机性来源</code></p>
<p><code>逻辑</code></p>
<p>实现的逻辑基本与朴素的指数机制相同，但是包括了效用函数的随机舍入，效用值夹紧，以及精确计算的额外监测</p>
<p><code>特定语言细节</code></p>
<p>python和rust语言实现上的区别</p>
<h5 id="4-1性能和应用"><a href="#4-1性能和应用" class="headerlink" title="4.1性能和应用"></a>4.1性能和应用</h5><p>所有的测试在拥有2核2GB内存的Linux虚拟机上，总体来说，Rust性能远远高于python，但是，由于基准测试的差异，呈现的实践不具有严格的可比性。</p>
<p><code>结果空间大小</code></p>
<p>选择了一个结果集𝑂 &#x3D; [𝑛]，且效用函数𝑢(𝑜) &#x3D; 𝑜。随着n的增大， 效用值范围和结果空间大小都增加。该测试证明：特别是在Rust语言中，即使是在低端配置情况下，当n&#x3D;75k时也能在大约10s内完成。</p>
<p>Note：base-2指数机制效率没有原始的指数机制效率高</p>
<p><code>精度确定方法</code></p>
<p>通过改变结果空间大小来展示经验精度确定的计算开销与精度降低之间的相对权衡导致的性能差异。该测试表明：随着n的增加，PythonEmp的性能远好于PythonTher的性能，即性能的改善效果要由于开销成本的增加；相反，RustEmp的性能却不如RustTher的性能</p>
<p><code>效用值范围</code></p>
<p>结果空间集固定为O&#x3D;1000，测试效用值范围增加时会怎样影响性能。设置𝑂 &#x3D; {0} ∪ {𝑖 +𝑛|𝑖 ∈ [𝑘]} 且𝑢(𝑜) &#x3D; 𝑜. 增长曲线是线性的，因为随着n的增加，成本增加的唯一原因是计算过程带来了更多的时间开销。</p>
<p><code>拉普拉斯</code></p>
<p>从拉普拉斯机制中采样的标准方法是使用逆变换采样，即在[0,1]中采样出一个均匀值U，然后求解CDF(t)&#x3D;U（CDF代表拉普拉斯分布的累积密度函数：对概率密度函数从−∞ 到t进行积分）。通过标准的ln函数实现该机制存在危险，但是通过[6]中提出的方法可以解决。</p>
<p>然后，拉普拉斯机制也可以通过将效用函数设置为𝑢(𝑑, 𝑜) &#x3D; |𝑓 (𝑑) −𝑜|进行实现。该测试表明：Python的性能由于PythonNaive，</p>
]]></content>
      <categories>
        <category>差分隐私（英文文献）</category>
      </categories>
      <tags>
        <tag>差分隐私</tag>
        <tag>Base-2指数机制</tag>
      </tags>
  </entry>
  <entry>
    <title>Locally Differentially Private Analysis of Graph Statistics</title>
    <url>/post/876b2f6a.html</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>图的差分隐私分析广泛用于从敏感图中发布数据并同时能保护用户隐私，但是大部分现有算法采用的是集中式的隐私模型，而这种模型由于服务器的可信赖性和数据泄露的可能性引起了大量的隐私和安全问题。本文提出了一种在本地差分隐私模型下计算子图个数的算法：</p>
<ul>
<li><p>对于三角形计数：提出了使用一轮交互和两轮交互的算法，结果表明两轮交互的算法可以提升效用；</p>
</li>
<li><p>对于<code>k-star</code>计数：提出了在非交互式环境下实现<strong>最优估计误差</strong>的算法；</p>
</li>
</ul>
<p>同时，本文对三角形个数和k星型个数等一般的图数据的估计误差提出了新的下界。最后，在两个真实数据集上进行了大量的实验，最终结果表明，在本地差分隐私模型中准确估计子图个数确实是有可能的。</p>
<span id="more"></span>

<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><h2 id="1-1-社交网络图"><a href="#1-1-社交网络图" class="headerlink" title="1.1 社交网络图"></a>1.1 社交网络图</h2><p>从社交网路图中可以分析得出一些图的性质，以下是社交网络图的几个基本性质：</p>
<ul>
<li><p><code>average degree</code>：即连接到某节点的边的个数，可以用来揭示平均连接性；</p>
</li>
<li><p><code>subgraph counts</code>：如三角形、星形、团的个数，可以用来衡量聚类系数等中心属性；</p>
</li>
<li><p><code>clustering coefficient</code>：表示一个人的两个朋友也会成为朋友的概率，其大小影响网络上的传播动力学，当其他参数不变时，平均节点聚类系数越大， 传播越慢。</p>
</li>
</ul>
<h2 id="1-2-主要挑战"><a href="#1-2-主要挑战" class="headerlink" title="1.2 主要挑战"></a>1.2 主要挑战</h2><p>本文主要考虑两种最基本的连接属性：子图计数和聚类系数：</p>
<ul>
<li><p>三角形：计数时不考虑<strong>自同构</strong>的情况；</p>
</li>
<li><p><code>k-star</code>形：一个中心节点连接着k个其他的节点；</p>
</li>
<li><p>聚类系数：<br>$$<br>3 * triangles&#x2F;2-stars<br>$$</p>
</li>
</ul>
<p><code>主要挑战</code>：</p>
<ul>
<li>在本地差分隐私模型中计算子图个数不能直接采用现有的对于表格式数据的算法和分析。现今本地差分隐私的研究内容主要集中于表格式数据，而缺乏对图这样复杂数据的研究；</li>
<li>表格式数据假定每个用户的数据是独立的，而在图数据中每个子图都是相互存在联系的。用户的这种相互依赖性成为了作者的算法思想来源：用户和服务器之间的额外交互可能会有所帮助。</li>
</ul>
<h2 id="1-3-本文贡献"><a href="#1-3-本文贡献" class="headerlink" title="1.3 本文贡献"></a>1.3 本文贡献</h2><ul>
<li>对于三角形计数，给出了两个算法：算法一基于随机相应和经验估计；算法二基于用户和服务器额外的一轮交互，同时为每个算法给出了估计误差的上界，结果表明算法二可以有效减小估计误差；</li>
<li>对于<code>k-star</code>形计数，基于拉普拉斯机制给出了一个简单的算法，并分析了该算法的估计误差的上界，结果表明在所有只采用一轮交互的<code>LDP</code>机制中，该算法在用户数量上是<strong>顺序最优</strong>的；</li>
<li>对本地模型中一般的图函数给出了估计误差的下界，这比集中式差分隐私中已知的上界更强，然后阐述了局部模型相对于集中式模型的一些限制；</li>
<li>在两个真实数据集上估计了本文提出的算法，结果表明在本地模型中准确估计子图个数确实是可能的，而且本文提出的算法当用户数量很大时估计误差也很小。</li>
</ul>
<h1 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2. 相关工作"></a>2. 相关工作</h1><ul>
<li><p>图<code>DP</code></p>
<ul>
<li><p>集中式模型：这种模型中已经提出了很多算法，如子图计数，度分布，特征值和特征向量，合成图等；</p>
</li>
<li><p>本地模型：这种模型中算法提出了很多算法，但是很少有关注子图计数的工作；</p>
<ul>
<li><code>Haipei Sun</code>等人基于一个假定提出了一个在本地模型中计算子图个数的算法，即每个用户允许他的朋友知道其整个好友列表。但这种假定在许多实际场景中是不可能成立的；</li>
<li><code>Qingqing Ye</code>等人基于对邻接矩阵采用随机响应机制提出了估计聚类系数的一轮交互算法。但是该算法在三角形计数中引入了很大的偏差，该团队之后发的一篇文章减小了该偏差，但是他们提出的新方法引入了一些近似值，而这些近似值不能确定是否是无偏的。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>LDP</code></p>
<ul>
<li>如上所述，现今<code>LDP</code>的研究主要针对表格式的数据进行数据分析和频繁项集挖掘，这些研究内容基本不考虑图数据中用户之间复杂的依赖关系；</li>
</ul>
</li>
<li><p>上界&#x2F;下界</p>
<ul>
<li>同样由于现有的<code>LDP</code>研究主要针对于表格式的数据，其假定每个原始的数据值都是从一个隐含的分布中独立采样得出的，因此这些研究中提出的上下界不适用于本文的图场景（在图中每个三角形和<code>k-star</code>都不是独立的，其与很多边都存在关联）。</li>
</ul>
</li>
</ul>
<h1 id="3-初步"><a href="#3-初步" class="headerlink" title="3. 初步"></a>3. 初步</h1><h2 id="3-1-图和DP"><a href="#3-1-图和DP" class="headerlink" title="3.1 图和DP"></a>3.1 图和DP</h2><ul>
<li><p>图</p>
<ul>
<li><b>n</b>：用户（节点）数量</li>
<li><b>d<sub>max</sub></b>：最大度</li>
</ul>
</li>
<li><p><code>DP</code>分类</p>
<ul>
<li>根据隐含结构：<ul>
<li>集中式<code>DP</code></li>
<li><code>LDP</code></li>
</ul>
</li>
<li>根据研究数据（如果是图数据）：<ul>
<li><code>edge DP</code>：两个邻居图只有一条边不同；</li>
<li><code>node DP</code>：两个邻居图相差一个节点（从图<b>G</b>中去除一个节点及其邻接边就得到了邻居图）</li>
</ul>
</li>
</ul>
</li>
<li><p><code>ε-edge centralized DP</code></p>
<img data-src="/post/undefined/1.png" class title="ε-edge centralized DP定义">

<blockquote>
<p><code>Note</code>:</p>
<ul>
<li>如果两个邻居图中有<b>k</b>条边不同，那么隐私预算就为<b>kε</b></li>
<li>集中式模型中的<code>edge DP</code>是两个邻居图，注意与下面的本地模型中的<code>edge DP</code>相区分</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="3-2-LDP"><a href="#3-2-LDP" class="headerlink" title="3.2 LDP"></a>3.2 LDP</h2><p>采用差分隐私保护用户数据一个首要原则就是需要先想清楚我们具体要保护用户的什么数据。对于图数据来说，本文考虑以下两种本地模型下的<code>edge DP</code>：<code>edge LDP</code>和<code>relationship DP</code>。</p>
<h3 id="3-2-1-Edge-LDP"><a href="#3-2-1-Edge-LDP" class="headerlink" title="3.2.1 Edge LDP"></a>3.2.1 Edge LDP</h3><p><code>edge LDP</code>的定义基于用户的邻居列表。图G可以用邻居列表表示为<b>a<sub>1</sub>, … , a<sub>n</sub></b>，其中<b>a<sub>i</sub></b>是邻接矩阵的第<b>i</b>行，且<b>a<sub>i</sub>&#x3D;(a<sub>i, 1</sub>, … ,a<sub>i, n</sub>) ∈ {0, 1}<sup>n</sup></b>，其具体定义如下：</p>
<img data-src="/post/undefined/2.png" class title="edge LDP定义">

<h3 id="3-2-2-Relationship-DP"><a href="#3-2-2-Relationship-DP" class="headerlink" title="3.2.2 Relationship DP"></a>3.2.2 Relationship DP</h3><p>在社交网络图中，通常两个用户会共享他们之间边的存在性信息，为了隐藏这条相互边，必须考虑两个用户的数出都可能泄露信息，因此本文提出了<code>relationship DP</code>。<code>relationship DP</code>定义如下：</p>
<img data-src="/post/undefined/3.png" class title="relationship DP定义">

<h3 id="3-2-3-各种DP间的区别"><a href="#3-2-3-各种DP间的区别" class="headerlink" title="3.2.3 各种DP间的区别"></a>3.2.3 各种DP间的区别</h3><ul>
<li><code>egde LDP</code>与<code>relationship DP</code>：<code>egde LDP</code>将同一条边<b>v<sub>i</sub>&lt;-&gt;v<sub>j</sub></b>在节点<b>v<sub>i</sub></b>和在节点<b>v<sub>j</sub></b>中看作是不同的信息，而在<code>relationship DP</code>中则认为两者相同；</li>
<li><code>LDP</code>与<code>relationship DP</code>：因为<code>LDP</code>中的每条用户数据都与其他数据相互独立，因此用户可以相信其他用户不会泄露自己的任何信息，而<code>relationship DP</code>研究的彼此存在相互依赖的图数据，因此只有花费隐私预算才能保证这一点，所以<code>relationship DP</code>的隐私保证比<code>LDP</code>更强；</li>
<li><strong><code>DP</code>与<code>relationship DP</code>：从两者的定义可以看出，<code>DP</code>是对真实值进行扰动，而<code>relationship DP</code>的隐私保证比<code>DP</code>更弱，因为在<code>DP</code>中服务器需要花费更多的隐私预算来保护用户的隐私数据。</strong></li>
</ul>
<h3 id="3-2-4-Edge-LDP与Relationship-DP的关系"><a href="#3-2-4-Edge-LDP与Relationship-DP的关系" class="headerlink" title="3.2.4 Edge LDP与Relationship DP的关系"></a>3.2.4 Edge LDP与Relationship DP的关系</h3><p><code>edge LDP</code>与<code>relationship DP</code>的关系如下图所示：</p>
<img data-src="/post/undefined/4.png" class title="edge LDP和relationship DP的关系">

<p>该定理说明，当我们需要将一条边作为一个整体进行保护时，隐私预算的开销需要加倍。考虑到该问题，本文提出了一些没有隐私开销加倍问题的随机算法：</p>
<ul>
<li><p>主要思想</p>
<ul>
<li>因为社交网络图可以用对称的邻接矩阵表示，因此考虑只对下三角矩阵进行扰动，从而去除了开销加倍的问题；</li>
</ul>
</li>
<li><p>具体做法</p>
<ul>
<li>使用随机响应算法对用户<b>i</b>的邻居列表<b>a<sub>i</sub></b>进行扰动时，只对<b>v<sub>1</sub>, … , v<sub>i-1</sub></b>进行扰动，因此随机算法<b>(R<sub>1</sub>, … , R<sub>n</sub>)</b>可以完成下三角矩阵的扰动过程，进而保护整个图数据，同时随机算法<b>(R<sub>1</sub>, … , R<sub>n</sub>)</b>的整个开销预算为<b>ε</b>。</li>
</ul>
</li>
</ul>
<h2 id="3-3-全局敏感度"><a href="#3-3-全局敏感度" class="headerlink" title="3.3 全局敏感度"></a>3.3 全局敏感度</h2><p>因为采用拉普拉斯机制去实现<code>edge centralized DP</code>和<code>edge DP</code>，所以需要考虑全局敏感度，其定义如下：</p>
<img data-src="/post/undefined/5.png" class title="全局敏感度">

<p>图中的全局敏感度可能会特别大，例如，在图中增加一条边可能会导致三角形的个数增加<b>n-2</b>（将新增的边作为新产生的三角形的一条边，那么再从剩下的<b>n-2</b>个节点中任意选出一个节点就可以构建一个三角形），<code>k-star</code>的个数增加<b>2C<sub>n</sub><sup>k-1</sup></b>（分别以新增的边的两个节点为<code>k-star</code>的中心，那么还需要从剩下的<b>n-2</b>个节点中选出<b>k-1</b>个节点就可以构建一个<code>k-star</code>）。一种降低全局敏感度的有效方法是采用<code>graph projection</code>，即从邻居列表中去除一些邻居从而使得最大度<b>d<sub>max</sub></b>可以以一个预定值<b>$\widetilde{d_{max}}$&lt;&lt;n</b>作为其上界，这种方法使得当在图中增加一条边时三角形的个数最多增加<b>$\widetilde{d_{max}}$</b>，<code>k-star</code>的个数最多增加<b>C<sub>$\widetilde{d_{max}}$</sub><sup>k-1</sup></b>。</p>
<p>一般选取最大度<b>d<sub>max</sub></b>作为<b>$\widetilde{d_{max}}$</b>的值，这样可以避免从邻居列表中去除邻居。然而最大度<b>d<sub>max</sub></b>可能会泄露原始图的隐私信息。因此在本文中采用了一种差分隐私随机梯度下降的自适应裁剪算法：先通过<code>edge LDP</code>估计出<b>d<sub>max</sub></b>的值，然后再将该值设置为<b>$\widetilde{d_{max}}$</b>的值。</p>
<h2 id="3-4-图数据和效用衡量"><a href="#3-4-图数据和效用衡量" class="headerlink" title="3.4 图数据和效用衡量"></a>3.4 图数据和效用衡量</h2><ul>
<li>图数据<ul>
<li>本文考虑一类图函数：以图<b>G</b>作为输入，输出三角形，<code>k-star</code>的个数和聚类系数等图数据；</li>
</ul>
</li>
<li>效用衡量<ul>
<li>本文使用均方误差（<b>l<sub>2</sub> loss</b>）和相对误差进行效用衡量。</li>
</ul>
</li>
</ul>
<h1 id="4-算法"><a href="#4-算法" class="headerlink" title="4. 算法"></a>4. 算法</h1><h2 id="4-1-模型构建"><a href="#4-1-模型构建" class="headerlink" title="4.1 模型构建"></a>4.1 模型构建</h2><ul>
<li><p>一轮交互模型</p>
<ul>
<li>服务器给用户<b>v<sub>i</sub></b>发送一次查询<b>R<sub>i</sub></b>，然后用户<b>v<sub>i</sub></b>单独发送其回答<b>R<sub>i</sub>(a<sub>i</sub>)</b>给服务器；</li>
</ul>
</li>
<li><p>多轮交互模型</p>
<ul>
<li>服务器给用户<b>v<sub>i</sub></b>发送多次查询<b>R<sub>i</sub></b>，然后用户<b>v<sub>i</sub></b>单独发送其回答<b>R<sub>i</sub>(a<sub>i</sub>)</b>给服务器，这种模型可能使得可能查询得到更准确的图统计数据；</li>
</ul>
</li>
</ul>
<h2 id="4-2-k-star的一轮交互算法-LocalLapk"><a href="#4-2-k-star的一轮交互算法-LocalLapk" class="headerlink" title="4.2 k-star的一轮交互算法(LocalLapk*)"></a>4.2 k-star的一轮交互算法(LocalLap<sub>k*</sub>)</h2><h3 id="4-2-1-算法描述"><a href="#4-2-1-算法描述" class="headerlink" title="4.2.1 算法描述"></a>4.2.1 算法描述</h3><p><code>k-star</code>的一轮交互算法(<b>LocalLap<sub>k*</sub></b>)具体如下图所示：</p>
<img data-src="/post/undefined/6.png" class title="k-star一轮交互算法">

<blockquote>
<p><code>k-star</code>的一轮交互算法(<b>LocalLap<sub>k*</sub></b>)<br>输入：用邻居列表<b>(a<sub>1</sub>, … , a<sub>n</sub>)</b>表示的图<b>G</b>，隐私预算<b>ε</b>，<b>$\widetilde{d_{max}}$</b>；</p>
<p>输出：<code>k-star</code>图形个数的估计值；</p>
<p>算法流程：</p>
<ul>
<li>初始化$\triangle$</li>
<li>对每一个邻居列表进行如下操作：<ul>
<li>将邻居列表进行映射，即限定节点的邻居数量必须 <b>&lt;&#x3D;</b> <b>$\widetilde{d_{max}}$</b>；</li>
<li>映射完毕后计算节点的度数；</li>
<li>计算以当前节点为中心的<code>k-star</code>图形的个数<b>r<sub>i</sub></b>；</li>
<li>将<b>r<sub>i</sub></b>添加拉普拉斯噪声然后发布；</li>
</ul>
</li>
<li>将所有<b>r<sub>i</sub></b>值进行求和并返回总和。</li>
</ul>
</blockquote>
<h3 id="4-2-2-算法理论证明"><a href="#4-2-2-算法理论证明" class="headerlink" title="4.2.2 算法理论证明"></a>4.2.2 算法理论证明</h3><p><b>LocalLap<sub>k*</sub></b>算法满足以下两个理论：</p>
<img data-src="/post/undefined/7.png" class title="理论">

<p>由于<b>LocalLap<sub>k*</sub></b>对邻居列表添加拉普拉斯噪声的总次数为<b>n</b>，所以复杂度中存在<b>n</b>；而在集中式模型中因为是对<code>k-star</code>总和进行加噪，所以复杂度中没有<b>n</b>。</p>
<p>在<code>edge centralized DP</code>模型中<b>f<sub>k*</sub></b>的敏感度为<b>2C<sub>$\widetilde{d_{max}}$</sub><sup>k-1</sup></b>，因此本文在实验过程中增加了一个<b>CentralLap<sub>k</sub></b>算法，其对<code>k-star</code>的真实值<b>f<sub>k</sub>(G)</b>添加一个拉普拉斯噪声，即<b>CentralLap<sub>k</sub></b>算法的输出值为：<b>f<sub>k</sub>(G)+Lap(2(C<sub>$\widetilde{d_{max}}$</sub><sup>k-1</sup>)&#x2F;ε)</b>。</p>
<h3 id="4-2-3-关于n的推论"><a href="#4-2-3-关于n的推论" class="headerlink" title="4.2.3 关于n的推论"></a>4.2.3 关于<b>n</b>的推论</h3><p>一轮交互算法中<b>n</b>存在以下推论：</p>
<img data-src="/post/undefined/8.png" class title="推论">

<p>本文在实验中发现当<b>n</b>很大时<b>LocalLap<sub>k*</sub></b>算法仍然能准确的估计<b>f<sub>k</sub>(G)</b>。而且，随着<b>n</b>的增大相对误差也逐渐减小。</p>
<h3 id="4-2-4-dmax的估计"><a href="#4-2-4-dmax的估计" class="headerlink" title="4.2.4 dmax的估计"></a>4.2.4 <b>d<sub>max</sub></b>的估计</h3><p>考虑到真实的<b>d<sub>max</sub></b>值可能会泄露隐私信息，因此需要增加一轮交互过程，具体算法过程描述如下：</p>
<blockquote>
<p>将隐私预算<b>ε</b>分解为两部分，<b>ε &#x3D; ε<sub>0</sub> + ε<sub>1</sub></b>，<b>ε<sub>0</sub></b>用于获取<b>d<sub>max</sub></b>，<b>ε<sub>0</sub></b>用于对<code>k-star</code>的个数值进行加噪；</p>
<p>然后服务器向每个用户发出询问，得到每个用户节点的度数，并据此得到最大度<b>d<sub>max</sub></b>，然后对其利用隐私预算<b>ε<sub>0</sub></b>对其进行加噪，并发布给所用用户节点；</p>
<p>最后再利用隐私预算<b>ε<sub>1</sub></b>执行<b>LocalLap<sub>k*</sub></b>算法并发布最终的<code>k-star</code>个数。</p>
</blockquote>
<p>可以看到两轮交互的算法同样提供<code>ε-edge LDP</code>的隐私保证。</p>
<h2 id="4-3-三角形的一轮交互算法-LocalRR-triangle"><a href="#4-3-三角形的一轮交互算法-LocalRR-triangle" class="headerlink" title="4.3 三角形的一轮交互算法(LocalRR$\triangle$)"></a>4.3 三角形的一轮交互算法(LocalRR<sub>$\triangle$</sub>)</h2><h3 id="4-3-1-算法思想"><a href="#4-3-1-算法思想" class="headerlink" title="4.3.1 算法思想"></a>4.3.1 算法思想</h3><p>该算法的思想就是随机响应<b>RR</b>和经验估计。值得注意的地方是服务器在拿到扰动后的用户数据时，此时如果直接计算三角形的个数，那么得到的结果将会是一个有偏的估计值。所以需要采用以下引理获取<b>f<sub>$\triangle$</sub>G</b>的无偏估计值：</p>
<img data-src="/post/undefined/9.png" class title="无偏估计值">

<h3 id="4-3-2-算法描述"><a href="#4-3-2-算法描述" class="headerlink" title="4.3.2 算法描述"></a>4.3.2 算法描述</h3><p>三角形的一轮交互算法（<b>LocalRR<sub>$\triangle$</sub></b>)算法具体如下图所示：</p>
<img data-src="/post/undefined/10.png" class title="三角形的一轮交互算法">

<blockquote>
<p>三角形的一轮交互算法(<b>LocalRR<sub>$\triangle$</sub></b>)</p>
<p>输入：用邻居列表<b>(a<sub>1</sub>, … , a<sub>n</sub>)</b>表示的图<b>G</b>，隐私预算<b>ε</b>；</p>
<p>输出：<b>f<sub>$\triangle$</sub>G</b>的估计值；</p>
<p>算法流程：</p>
<ul>
<li>每个用户<b>v<sub>i</sub></b>使用隐私预算<b>ε</b>对其邻居列表(<b>a<sub>i, 1</sub>, … , a<sub>i, i-1</sub></b>)进行扰动，然后发布其扰动之后的邻居列表(<b>RR<sub>ε</sub>(a<sub>i, 1</sub>), … , RR<sub>ε</sub>(a<sub>i, i-1</sub>)</b>)；</li>
<li>服务器根据所有用户上传的扰动之后的邻居列表及无向图的对称性去构建一个无向图<b>G’</b>；</li>
<li>服务器从无向图<b>G’</b>中数出<b>m<sub>0</sub></b>, <b>m<sub>1</sub></b>, <b>m<sub>2</sub></b>, <b>m<sub>3</sub></b>的个数，并使用公式<b>(4)</b>计算<b>f<sub>$\triangle$</sub>G</b>的无偏估计值，最后返回该无偏估计值。</li>
</ul>
</blockquote>
<h3 id="4-3-3-算法理论证明"><a href="#4-3-3-算法理论证明" class="headerlink" title="4.3.3 算法理论证明"></a>4.3.3 算法理论证明</h3><p><b>LocalRR<sub>$\triangle$</sub></b>算法满足以下两个理论：</p>
<img data-src="/post/undefined/11.png" class title="理论">

<img data-src="/post/undefined/12.png" class title="理论">

<p>本文在实验过程中增加了一个<b>CentralLap<sub>$\triangle$</sub></b>算法，其对三角形个数的真实值<b>f<sub>$\triangle$</sub>G</b>添加一个拉普拉斯噪声，即输出值为：<b>f<sub>$\triangle$</sub>G + Lap($\widetilde{d_{max}}$&#x2F;ε)</b>。</p>
<h3 id="4-3-4-误差分析"><a href="#4-3-4-误差分析" class="headerlink" title="4.3.4 误差分析"></a>4.3.4 误差分析</h3><p><b>LocalRR<sub>$\triangle$</sub></b>算法的误差来源于三角形的每条边都是以某种被翻转的概率独立上传，即三条边相当于图<b>G’</b>中的三个随机变量。</p>
<h2 id="4-4-三角形的两轮交互算法-Local2Rounds-triangle"><a href="#4-4-三角形的两轮交互算法-Local2Rounds-triangle" class="headerlink" title="4.4 三角形的两轮交互算法(Local2Rounds$\triangle$)"></a>4.4 三角形的两轮交互算法(Local2Rounds<sub>$\triangle$</sub>)</h2><h3 id="4-4-1-算法思想"><a href="#4-4-1-算法思想" class="headerlink" title="4.4.1 算法思想"></a>4.4.1 算法思想</h3><p>显然，如果只采用一轮交互，那么每个用户不可能知道是否存在三角形，但是如果增加一轮交互，即在第一轮交互之后，服务器发布加噪之后得到的无向图<b>G’</b>，用户可以根据无向图<b>G’</b>去判断第三条边的存在性。这样每个用户就可以数出三角形的个数。同样值得注意的是，计算得出的无向图<b>G’</b>中三角形的个数肯定是无偏的，因此需要根据以下引理进行计算，从而得到一个<b>f<sub>$\triangle$</sub>G</b>的无偏估计值：</p>
<img data-src="/post/undefined/13.png" class title="引理">

<img data-src="/post/undefined/14.png" class title="引理">

<h3 id="4-4-2-算法描述"><a href="#4-4-2-算法描述" class="headerlink" title="4.4.2 算法描述"></a>4.4.2 算法描述</h3><p>三角形的两轮交互算法(<b>Local2Rounds<sub>$\triangle$</sub></b>)具体如下图所示：</p>
<img data-src="/post/undefined/15.png" class title="三角形的两轮交互算法">

<blockquote>
<p>三角形的两轮交互算法(<b>Local2Rounds<sub>$\triangle$</sub></b>)</p>
<p>输入：用邻居列表<b>(a<sub>1</sub>, … , a<sub>n</sub>)</b>表示的图<b>G</b>，两个隐私预算<b>ε<sub>1</sub></b>, <b>ε<sub>2</sub></b>，$\widetilde{d_{max}}$；</p>
<p>输出：<b>f<sub>$\triangle$</sub>G</b>的估计值；</p>
<p>算法流程：</p>
<ul>
<li>每个用户<b>v<sub>i</sub></b>使用隐私预算<b>ε</b>对其邻居列表(<b>a<sub>i, 1</sub>, … , a<sub>i, i-1</sub></b>)进行扰动，然后发布其扰动之后的邻居列表(<b>RR<sub>ε</sub>(a<sub>i, 1</sub>), … , RR<sub>ε</sub>(a<sub>i, i-1</sub>)</b>)；</li>
<li>服务器根据所有用户上传的扰动之后的邻居列表及无向图的对称性去构建一个无向图<b>G’</b>，同时将无向图<b>G’</b>发布；</li>
<li>每个用户收到无向图<b>G’</b>之后，首先将邻居列表进行映射，即限定节点的邻居数量必须 <b>&lt;&#x3D;</b> $\widetilde{d_{max}}$，然后数出<b>t<sub>i</sub></b>和<b>s<sub>i</sub></b>的个数，并根据上述引理得到<b>w<sub>i</sub></b>，然后再使用拉普拉斯机制对<b>w<sub>i</sub></b>进行加噪处理，最后将其发送给服务器；</li>
<li>服务器收到每个用户的<b>w<sub>i</sub></b>后，采用上述引理得到<b>f<sub>$\triangle$</sub>G</b>的估计值，最后返回该无偏估计值。</li>
</ul>
</blockquote>
<h3 id="4-4-3-算法理论证明"><a href="#4-4-3-算法理论证明" class="headerlink" title="4.4.3 算法理论证明"></a>4.4.3 算法理论证明</h3><p><b>Local2Rounds<sub>$\triangle$</sub></b>算法满足以下两个理论：</p>
<img data-src="/post/undefined/16.png" class title="理论一">

<img data-src="/post/undefined/17.png" class title="理论二">

<p>从第二个理论中可以看出，通过增加一轮交互，均方误差从<b>O(n<sup>4</sup>)</b>减小到了<b>O($\widetilde{d_{max}^3}$n)</b>。</p>
<h3 id="4-4-4-dmax的估计"><a href="#4-4-4-dmax的估计" class="headerlink" title="4.4.4 dmax的估计"></a>4.4.4 d<sub>max</sub>的估计</h3><p>上面的<b>Local2Rounds<sub>$\triangle$</sub></b>算法将<b>d<sub>max</sub></b>作为其输入，但是并没有提及其获取方式。实际上，在<b>Local2Rounds<sub>$\triangle$</sub></b>算法中采用与<b>LocalLap<sub>k*</sub></b>同样的获取方式。具体来说，可以将隐私预算<b>ε</b>分成三份，即<b>ε &#x3D; ε<sub>0</sub> + ε<sub>1</sub> + ε<sub>2</sub></b>。在第一轮交互过程中，每个用户使用<b>ε<sub>0</sub></b>上传加噪之后的度<b>d<sub>i</sub></b>，同时需要使用<b>ε<sub>1</sub></b>上传其加噪之后的邻居列表；在第二轮交互过程中，服务器首先根据每个<b>d<sub>i</sub></b>获取最大度<b>d<sub>max</sub></b>，然后再进行之后的操作。</p>
<p>总体来说，整个算法提供<code>(ε0 + ε1 + ε2)-edge LDP</code>和<code>(2ε0 + ε1 + ε2)-relationship LDP</code>。</p>
<h3 id="4-4-5-时间复杂度和通信开销"><a href="#4-4-5-时间复杂度和通信开销" class="headerlink" title="4.4.5 时间复杂度和通信开销"></a>4.4.5 时间复杂度和通信开销</h3><ul>
<li>时间复杂度<ul>
<li><b>LocalRR<sub>$\triangle$</sub></b>算法是低效的，因为该算法需要从<b>G’</b>中数出三角形的个数<b>m<sub>3</sub></b>，而在图中总共有<b>C<sup>3</sup><sub>n</sub></b>个包含三个节点的子图，因此该过程的时间复杂度为<b>O(n<sup>3</sup>)</b>；</li>
<li>相反，<b>Local2Rounds<sub>$\triangle$</sub></b>算法的时间复杂度为<b>O(n<sup>2</sup> + nd<sup>2</sup><sub>max</sub>)</b>。其中<b>n<sup>2</sup></b>是由于无向图<b>G’</b>的大小为<b>n<sup>2</sup></b>。</li>
</ul>
</li>
<li>通信开销<ul>
<li>每个用户需要根据无向图<b>G’</b>去数出<b>t<sub>i</sub></b>和<b>s<sub>i</sub></b>的个数，这肯定会导致<b>O(n<sup>2</sup>)</b>的通信开销。但本文没有在实验中估计该算法的通信开销。</li>
</ul>
</li>
</ul>
<h2 id="4-5-下界"><a href="#4-5-下界" class="headerlink" title="4.5 下界"></a>4.5 下界</h2><p>本小节主要探讨在一轮交互模型的所有算法中，复杂度是否中一定包含<b>n</b>，推导结果表明回答是肯定的。</p>
<p>输入图的具体结构定义如下图所示：</p>
<img data-src="/post/undefined/18.png" class title="输入图结构定义">

<p>根据上述结构定义，本文给出了下界的证明，如下图所示：</p>
<img data-src="/post/undefined/19.png" class title="下界证明">

<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>本文提出了在本地差分隐私模型中计算子图个数的算法：具体来说，对于三角形计数，给出了一轮交互算法和两轮交互算法；对于<code>k-star</code>计数，给出了一轮交互算法。同时，本文证明了所有一轮交互算法的时间复杂度一定会包含用户节点个数<b>n</b>。</p>
<p><code>思考</code>：</p>
<blockquote>
<ul>
<li>两轮交互的三角形计算算法中，每个用户都能获取加躁之后的社交网络图，那么实际上攻击者是可以直接从这个图数出三角形的个数的，如果第二轮加躁之后再把个数上传给服务器，之后服务器再求和，那么这个求和结果与直接从加躁之后的图中数出的结果会不会相差很大？而这个差别会不会带来什么影响？如果存在影响那应该怎么解决？</li>
<li>‌同样是上述算法，在第二轮给三角形个数加躁的过程中，噪声完全覆盖真实值的情况感觉完全有可能发生，那这种情况下会不会导致发布的三角形计数结果误差过大？所以是否可以采用动态调节的思想，当计数小于某个阈值时就不加躁？如果可以的话阈值应该怎么确定？</li>
<li>‌图中的度分布求解发布等问题感觉可以采用边缘列联表发布的方法去解决，是不是可以沿着这个思路尝试一下</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>差分隐私（英文文献）</category>
      </categories>
      <tags>
        <tag>差分隐私</tag>
        <tag>图差分隐私</tag>
      </tags>
  </entry>
</search>
